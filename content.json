[{"title":"Android多屏幕专题--双Home的启动","date":"2020-03-22T02:54:36.000Z","path":"2020/03/22/Android多屏幕专题-双Home的启动/","text":"Android多屏幕专题 – 双Home的启动​ 在一个偶然的机会下，发现AndroidQ是支持两个Launcher的，在两个显示设备的情况下，可以分别启动两个Launcher，在这两个Launcher中都可以操作，如打开应用，虚拟导航栏等，也就是说，使用这种模式，是可以同时打开两个应用分别操作。 ​ 启动双Home的方式，首先是这个Android系统不能是低内存设备(low ram device)，其次可通过settings put global force_desktop_mode_on_external_displays 1，重启后两个显示器上就有不同的Home了。 ​ 下面我们就来看看这个settings字段是如何控制双Home的启动。前面的代码追溯我们就不一一展开，直接从SystemServer启动完成后就会调用AMS的systemReady方法，而在AMS的systemReady中就会去启动我们的Launcher: 123456789101112131415161718192021 8960 public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) &#123; …… 9076 mAtmInternal.startHomeOnAllDisplays(currentUserId, \"systemReady\"); …… 9136 &#125;6691 @Override6692 public boolean startHomeOnAllDisplays(int userId, String reason) &#123;6693 synchronized (mGlobalLock) &#123;6694 return mRootActivityContainer.startHomeOnAllDisplays(userId, reason);6695 &#125;6696 &#125; 332 boolean startHomeOnAllDisplays(int userId, String reason) &#123; 333 boolean homeStarted = false; 334 for (int i = mActivityDisplays.size() - 1; i &gt;= 0; i--) &#123; 335 final int displayId = mActivityDisplays.get(i).mDisplayId; 336 homeStarted |= startHomeOnDisplay(userId, reason, displayId); 337 &#125; 338 return homeStarted; 339 &#125; startHomeOnDisplay​ mActivityDisplays中记录了启动过程中所注册进来的display，在AMS中，使用ActivityDisplay来描述显示屏，这里的startHomeOnAllDisplays就是去为所有的显示屏去启动一个Home，当然啦，并不是一定会为每个屏幕都启动一个Home. 1234567891011121314151617181920212223242526272829303132333435363738394041424344350 boolean startHomeOnDisplay(int userId, String reason, int displayId) &#123;351 return startHomeOnDisplay(userId, reason, displayId, false /* allowInstrumenting */,352 false /* fromHomeKey */);353 &#125;366 boolean startHomeOnDisplay(int userId, String reason, int displayId, boolean allowInstrumenting,367 boolean fromHomeKey) &#123;368 // Fallback to top focused display if the displayId is invalid.369 if (displayId == INVALID_DISPLAY) &#123;370 displayId = getTopDisplayFocusedStack().mDisplayId;371 &#125;372373 Intent homeIntent = null;374 ActivityInfo aInfo = null;375 if (displayId == DEFAULT_DISPLAY) &#123;376 homeIntent = mService.getHomeIntent();377 aInfo = resolveHomeActivity(userId, homeIntent);378 &#125; else if (shouldPlaceSecondaryHomeOnDisplay(displayId)) &#123;379 Pair&lt;ActivityInfo, Intent&gt; info = resolveSecondaryHomeActivity(userId, displayId);380 aInfo = info.first;381 homeIntent = info.second;382 &#125;383 if (aInfo == null || homeIntent == null) &#123;384 return false;385 &#125;386387 if (!canStartHomeOnDisplay(aInfo, displayId, allowInstrumenting)) &#123;388 return false;389 &#125;390391 // Updates the home component of the intent.392 homeIntent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));393 homeIntent.setFlags(homeIntent.getFlags() | FLAG_ACTIVITY_NEW_TASK);394 // Updates the extra information of the intent.395 if (fromHomeKey) &#123;396 homeIntent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, true);397 &#125;398 // Update the reason for ANR debugging to verify if the user activity is the one that399 // actually launched.400 final String myReason = reason + \":\" + userId + \":\" + UserHandle.getUserId(401 aInfo.applicationInfo.uid) + \":\" + displayId;402 mService.getActivityStartController().startHomeActivity(homeIntent, aInfo, myReason,403 displayId);404 return true;405 &#125; ​ 当displayId等于DEFAULT_DISPLAY，即主显的时候，必然会给其找一个Launcher进行启动。当displayId不是DEFAULT_DISPLAY，即非主显时，就要过三关了： ​ 第一关，系统是否支持SecondaryHomeOnDisplay–shouldPlaceSecondaryHomeOnDisplay，如果系统没有配置打开，那么AMS就不会启动双Home了。 ​ 第二关，系统中有定义SecondaryHomeActivity–resolveSecondaryHomeActivity，如果没有第二个Launcher，那么也就没有可以使用的Activity，AMS根本就没法启动。 ​ 第三关，检查是否允许在对应的display中启动Home–canStartHomeOnDisplay，如果是AMS在启动的时候，是不会有问题的。 shouldPlaceSecondaryHomeOnDisplay​ 先看第一关考验的内容： 12345678910111213141516171819202122232425262728293031323334540 boolean shouldPlaceSecondaryHomeOnDisplay(int displayId) &#123;541 if (displayId == DEFAULT_DISPLAY) &#123;542 throw new IllegalArgumentException(543 \"shouldPlaceSecondaryHomeOnDisplay: Should not be DEFAULT_DISPLAY\");544 &#125; else if (displayId == INVALID_DISPLAY) &#123;545 return false;546 &#125;547548 if (!mService.mSupportsMultiDisplay) &#123;549 // Can't launch home on secondary display if device does not support multi-display.550 return false;551 &#125;552553 final boolean deviceProvisioned = Settings.Global.getInt(554 mService.mContext.getContentResolver(),555 Settings.Global.DEVICE_PROVISIONED, 0) != 0;556 if (!deviceProvisioned) &#123;557 // Can't launch home on secondary display before device is provisioned.558 return false;559 &#125;560561 if (!StorageManager.isUserKeyUnlocked(mCurrentUser)) &#123;562 // Can't launch home on secondary displays if device is still locked.563 return false;564 &#125;565566 final ActivityDisplay display = getActivityDisplay(displayId);567 if (display == null || display.isRemoved() || !display.supportsSystemDecorations()) &#123;568 // Can't launch home on display that doesn't support system decorations.569 return false;570 &#125;571572 return true;573 &#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"AMS","slug":"AMS","permalink":"https://chongyuzhao.github.io/tags/AMS/"}]},{"title":"Android多屏幕专题--开篇","date":"2020-03-21T13:58:57.000Z","path":"2020/03/21/Android多屏幕专题-开篇/","text":"Android多屏幕​ Android从4.4开始其实就已经有了(不确定最初是哪个版本)，在Android6.0的时候就有Presentation作为异显开发，而到AndroidQ，就已经发现有双Home(两个launcher，可以在两个显示屏上打开应用)。而我对这一块一直都比较感兴趣，而且涉及了Android frameworks很多的内容，诸如AMS、WMS、DisplayManagerService、SurfaceFlinger和Input等等。随着嵌入式芯片的性能越来越强，多屏操作也就不再吃力，Android也越来越接近像windows那样强大的界面操作能力。 分析步骤​ 由于多屏幕异显部分设计的子系统繁多，我们将逐一分块进行分析，大概步骤如下: ​ 1.从双home场景进行分析，了解两个Home是如何启动与显示。 ​ 2.了解Presentation的原理，分析其是如何显示到其他的屏幕上。 ​ 3.了解AMS是如何管理多个屏幕的，如何组织或者启动一个Activity到另一个屏幕上。 ​ 4.了解WMS是如何管理多个屏幕的windows。 ​ 5.了解SurfaceFlinger是如何合成和显示不同屏幕的视图。 ​ 6.了解InputFlinger的不同屏幕的Viewport更新机制。 ​ ……","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"},{"name":"AMS","slug":"AMS","permalink":"https://chongyuzhao.github.io/tags/AMS/"},{"name":"WMS","slug":"WMS","permalink":"https://chongyuzhao.github.io/tags/WMS/"}]},{"title":"Android Input子系统专题-输入路由","date":"2020-03-20T13:19:34.000Z","path":"2020/03/20/Android-Input子系统专题-输入路由/","text":"Android Input输入路由​ 路由在我们生活中基本都有接触，而我们这里说的输入路由主要是用在多屏幕多触摸输入设备中，设计者可以为对应的屏幕指定对应的输入设备，而这功能就是所谓的输入路由。 ​ 从InputFlinger的学习中我们知道，在InputFlinger中没有屏幕(Screen)的概念，而我们的输入事件是通过查找对应的Viewport(视口)来发送到对应的窗口，而窗口在指定的屏幕上，也即是对应的输入事件发送到指定的屏幕中。在底层我们是不知道哪个触摸设备对应哪个屏幕的，例如当有两个HDMI设备时，那么我们哪个触摸设备对应哪个显示器呢，这是很不好去判断的，一般查找Viewport有以下4种情况： ​ 1.如果有在设备路由表中定义，则根据路由表的display id进行查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 2.如果idc配置文件中有定义touch.displayId字段，则根据该字段进行匹配查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 3.根据设备类型进行查找，如果设备属于内置类型输入设备，则会匹配到内置的display，而如果属于外置输入设备，如usb触摸屏等，则会去匹配外置的display。 ​ 4.在第3点的以外情况，即如果是外置输入设备，但没有匹配到外置的display，则会匹配默认的内置display。 ​ 以上4种情况可直接参考TouchInputMapper::findViewport的具体实现。 ​ 输入路由就是针对第一种情况。具体的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940413458 std::optional&lt;DisplayViewport&gt; TouchInputMapper::findViewport() &#123;3459 if (mParameters.hasAssociatedDisplay) &#123;3460 const std::optional&lt;uint8_t&gt; displayPort = mDevice-&gt;getAssociatedDisplayPort();3461 if (displayPort) &#123;3462 // Find the viewport that contains the same port3463 std::optional&lt;DisplayViewport&gt; v = mConfig.getDisplayViewportByPort(*displayPort);3464 if (!v) &#123;3465 ALOGW(\"Input device %s should be associated with display on port %\" PRIu8 \", \"3466 \"but the corresponding viewport is not found.\",3467 getDeviceName().c_str(), *displayPort);3468 &#125;3469 return v;3470 &#125; ……3501 &#125; 262 inline std::optional&lt;uint8_t&gt; getAssociatedDisplayPort() const &#123; 263 return mAssociatedDisplayPort; 264 &#125; 1067 void InputDevice::configure(nsecs_t when, const InputReaderConfiguration* config, uint32_t changes) &#123;1068 mSources = 0;1069 ……11001101 if (!changes || (changes &amp; InputReaderConfiguration::CHANGE_DISPLAY_INFO)) &#123;1102 // In most situations, no port will be specified.1103 mAssociatedDisplayPort = std::nullopt;1104 // Find the display port that corresponds to the current input port.1105 const std::string&amp; inputPort = mIdentifier.location;1106 if (!inputPort.empty()) &#123;1107 const std::unordered_map&lt;std::string, uint8_t&gt;&amp; ports = config-&gt;portAssociations;1108 const auto&amp; displayPort = ports.find(inputPort);1109 if (displayPort != ports.end()) &#123;1110 mAssociatedDisplayPort = std::make_optional(displayPort-&gt;second);1111 &#125;1112 &#125;1113 &#125;1114 ……1120 &#125; ​ 从上述的代码可以看到，输入路由就是通过InputDevice的location来从portAssociations表中去查找display。portAssociations的值我们可以逆推找到，也可以从官网的介绍文档中得知 – /vendor/etc/input-port-associations.xml，值的获取如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501905 private static String[] getInputPortAssociations() &#123;1906 File baseDir = Environment.getVendorDirectory();1907 File confFile = new File(baseDir, PORT_ASSOCIATIONS_PATH);19081909 try &#123;1910 InputStream stream = new FileInputStream(confFile);1911 List&lt;Pair&lt;String, String&gt;&gt; associations =1912 ConfigurationProcessor.processInputPortAssociations(stream);1913 List&lt;String&gt; associationList = flatten(associations);1914 return associationList.toArray(new String[0]);1915 &#125; catch (FileNotFoundException e) &#123;1916 // Most of the time, file will not exist, which is expected.1917 &#125; catch (Exception e) &#123;1918 Slog.e(TAG, \"Could not parse '\" + confFile.getAbsolutePath() + \"'\", e);1919 &#125;1920 return new String[0];1921 &#125; 88 @VisibleForTesting 89 static List&lt;Pair&lt;String, String&gt;&gt; processInputPortAssociations(InputStream xml) 90 throws Exception &#123; 91 List&lt;Pair&lt;String, String&gt;&gt; associations = new ArrayList&lt;&gt;(); 92 try (InputStreamReader confReader = new InputStreamReader(xml)) &#123; 93 XmlPullParser parser = Xml.newPullParser(); 94 parser.setInput(confReader); 95 XmlUtils.beginDocument(parser, \"ports\"); 96 97 while (true) &#123; 98 XmlUtils.nextElement(parser); 99 String entryName = parser.getName();100 if (!\"port\".equals(entryName)) &#123;101 break;102 &#125;103 String inputPort = parser.getAttributeValue(null, \"input\");104 String displayPort = parser.getAttributeValue(null, \"display\");105 if (TextUtils.isEmpty(inputPort) || TextUtils.isEmpty(displayPort)) &#123;106 // This is likely an error by an OEM during device configuration107 Slog.wtf(TAG, \"Ignoring incomplete entry\");108 continue;109 &#125;110 try &#123;111 Integer.parseUnsignedInt(displayPort);112 &#125; catch (NumberFormatException e) &#123;113 Slog.wtf(TAG, \"Display port should be an integer\");114 continue;115 &#125;116 associations.add(new Pair&lt;&gt;(inputPort, displayPort));117 &#125;118 &#125;119 return associations;120 &#125; ​ 从代码上看，输入路由的配置文件input-port-associations.xml的格式如下： 1234&lt;ports&gt; &lt;port display=\"0\" input=\"usb-xhci-hcd.0.auto-1.1/input0\" /&gt; &lt;port display=\"1\" input=\"usb-xhci-hcd.0.auto-1.2/input0\" /&gt;&lt;/ports&gt; ​ 顶层以为tag，子节点为一组display-input配置。display属性是一个整形值，对应了displayId，input属性是输入设备的描述。回顾InputDevice::configure方法的内容，input的字段对应了InputDevice的location字段。displayId我们很好理解，就是显示设备在Display系统中的idz中，我们可以通过dumpsys display来获取，而这个location值也可以通过dumpsys input来获取设备对应的值。 ​ 我们再看以下location这个值是从哪里来的： 12345678910111189 status_t EventHub::openDeviceLocked(const char* devicePath) &#123; ……1240 // Get device physical location.1241 if(ioctl(fd, EVIOCGPHYS(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;1242 //fprintf(stderr, \"could not get location for %s, %s\\n\", devicePath, strerror(errno));1243 &#125; else &#123;1244 buffer[sizeof(buffer) - 1] = '\\0';1245 identifier.location = buffer;1246 &#125; ……1477 &#125; ​ location就是input设备驱动中的phys。 总结​ 输入路由其实就是简单的由一个xml文件对输入设备(触摸设备)和显示设备之间进行绑定。我觉得可以由以下的用途： ​ 1.多个外置的输入设备和显示设备，需要指定对应的输入和显示设备关系，可以使用输入路由控制。 ​ 2.一个内置一个外置的输入设备和显示设备。当两个显示器进行同显时(此时只有一个viewport)，那么两个输入设备都可以控制主显，而我们又不希望如此时，可以通过输入路由指定外置输入设备控制外置显示设备(即当只有异显时才生效)。 ​ 3.将某个输入设备的display设成一个不存在的displayId，那么就可以禁止掉输入设备的事件(有点多此一举，因为可通过excluded-input-devices.xml让对应的设备不进行注册，但这种做法可以禁止掉一类型的输入设备事件上报，也不失为一种方式)。 ​ 如果大家还有其他想到的用途，欢迎交流~ ，","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android Input子系统专题-InputFlinger(一)","date":"2020-03-15T13:39:40.000Z","path":"2020/03/15/Android-Input子系统专题-InputFlinger/","text":"InputFlinger的启动​ InputFlinger在Android(至少在AndroiP及以后的版本)中作为一个服务而存在，如果有学习过Android的服务启动，那么对InputFlinger的启动也将会十分熟悉，在本文将简单地介绍一下它的启动。 ​ InputFlinger的源码在frameworks/native/services/inputflinger目录下，在该目录下有一个host目录，这里面就是InputFlinger的服务程序，而与host目录同级下的源码则是InputFlinger的核心代码–libinputflinger。 ​ 在host目录下有一个inputflinger.rc文件： 12345service inputflinger &#x2F;system&#x2F;bin&#x2F;inputflinger class main user system group input wakelock# onrestart restart zygote ​ InputFlinger属于main组别的服务，group是input和wakelock，由于需要读取/dev/input/*下的设备节点，因此需要input group，而且部分设备还具备唤醒系统，因此还有wakelock的group。 ​ 最后一个onrestart restart zygote，说明之前的版本inputflinger如果挂掉，那么Android将会重启，但AndroidP后就不需要这么做了，因为当inputflinger挂掉后，init会将它重启。而其他地方估计是没有其他的服务去引用它，其相对独立。这个可在后续研究一下。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android input子系统专题--开篇","date":"2020-03-15T05:16:00.000Z","path":"2020/03/15/Android-input子系统专题-开篇/","text":"Android Input的分层​ Android的input子系统大概是在2019年的3、4月份开始接触的，主要是因为负责Input部分的同事离职了，我就当仁不让地接上了这个话。Android是一个交互式的操作系统，显示与输入都是一个重要的组成部分。Android支持多种多样的输入设备，如触摸、游戏手柄、按键、鼠标、键盘等等。 ​ 基于Android与Linux的关系，Android的input子系统也是可分成三层：设备驱动层 - inputflinger层 - 应用处理层。设备驱动层与inputflinger层之间是通过Linux的设备驱动节点进行连接，inputflinger与应用层之前是通过InputChannel来进行连接。 123graph BTDriver[设备驱动] &#x3D;&#x3D; VFS &#x3D;&#x3D;&gt; InputFlinger[InputFlinger]InputFlinger[InputFlinger] &#x3D;&#x3D; InputChannel &#x3D;&#x3D;&gt; APP[应用] ​ 设备驱动层决定了系统支持什么类型的设备，没有对应的驱动配置就成了巧妇难为无米之炊，如果没有触摸驱动，那么如何来触摸，USB没有配置好，那么USB鼠标键盘如何使用。设备驱动层是基础，后面在对这部分分析的时候，我们不针对具体的设备驱动，而是对input事件的从驱动层到用户节点的过程。 ​ inputflinger是Android的快递员，接收底层驱动投递的输入事件，然后经过封装分发给对应的客户。这一块也是目前接触最多的部分，后面将重点分析这一块。 ​ 应用层则是Android真正处理事件的地方，输入事件的存在感就是由处理它的人体验的，这一部分很多时候已经被各种view给处理，剩余的则由应用去处理，平时我们所override的onKeyDown/onTouchEvent等等回调，就是我们研究的对象。 分析步骤1. InputFlinger的工作原理 1. 设备的配置文件 2. KeyEvent的处理过程 3. TouchEvent的处理过程 2. InputChannel的创建 3. InputFlinger分发事件到应用的过程 4. Driver的事件上报过程。总结​ 学无止境，每次重新看代码都会有不同的感悟，特别是Android版本的更新频繁，虽大体的框架不会变动太大，但也是有无穷的东西需要学习和总结。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"input","slug":"input","permalink":"https://chongyuzhao.github.io/tags/input/"}]}]