[{"title":"display-layerstack","date":"2020-12-05T02:00:58.000Z","path":"2020/12/05/display/display-layerstack/","text":"Display layerStack前文背景​ 之前有人问在双屏机器下同显时打开开发者选项中的PointerLocation时，主显会正常显示PointerLocationView下的界面以及PointerLocationView，而副显上则没有了底下的界面，只有PointerLocationView.​ 通过dumpsys SurfaceFlinger可以看到，display1只有一个图层，因此副显上肯定是只能看到PointerLocationView。通过dumpsys SurfaceFlinger同时可以看到各个display的layer列表以及layerStack，同显(关闭PointerLocation)时副显的layerStack为0，异显(打开PointerLocation或者打开双Launcher)时副显的layerStack为1。因此这个的关键是display所使用的layerStack。 ​ 本文就是从这个角度进行分析。 PointerLocationView的创建 ​ 1.PointerLocationView的创建是由Settings.System.POINTER_LOCATION(pointer_location)这个Settings字段进行控制，开机时WMS会对其进行检测，如果是enabled状态，则会主动创建它，并创建SettingsObserver去监听这个字段的变化，当发生变化时会调用updatePointerLocation这个方法进行更新。 ​ 2.updatePointerLocation会遍历所有的display(DisplayPolicy)，调用DisplayPolicy.setPointerLocationEnabled来处理这个事件，DefaultDisplay和非私有的display都是支持PointerLocation的。 ​ 3.enabled时调用enablePointerLocation来创建PointerLocationView，并注册到WMS中；而disabled则直接调用disablePointerLocation从WMS中将PointerLocationView remove掉。 ​ 4.PointerLocationView的创建所使用的参数使其成为一个系统窗口，位于所有layer的最顶端，因此其不会被其他的窗口所遮挡，其次其不创建InputChannel，因此不会接收任何的输入事件，不会成为焦点窗口。 display layerStack的设置过程 ​ display的layerStack流程大概如上所示，我们不继续往前追溯，单纯从DisplayContent.applySurfaceChangesTransaction开始看，DisplayContent中有一个ApplySurfaceChangesTransactionState的实例mTmpApplySurfaceChangesTransactionState，这里面保存了Display的Surface的状态，其中与layerStack相关的就有displayHasContent，表示该display是否有其相关的内容。在applySurfaceChangesTransaction中会reset这个实例中的所有状态，其状态是由applySurfaceChangesTransaction运行时计算所得。此时默认displayHasContent为false。 ​ 然后通过遍历DisplayContent中所有的windows，执行mApplySurfaceChangesTransaction的操作，而这里就会去计算displayHasContent的值： 1234798 mTmpApplySurfaceChangesTransactionState.displayHasContent |=799 root.handleNotObscuredLocked(w,800 mTmpApplySurfaceChangesTransactionState.obscured,801 mTmpApplySurfaceChangesTransactionState.syswin); ​ root是RootWindowContainer的实例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061865 boolean handleNotObscuredLocked(WindowState w, boolean obscured, boolean syswin) &#123;866 final WindowManager.LayoutParams attrs = w.mAttrs;867 final int attrFlags = attrs.flags;868 final boolean onScreen = w.isOnScreen();869 final boolean canBeSeen = w.isDisplayedLw();870 final int privateflags = attrs.privateFlags;871 boolean displayHasContent = false;872873 if (DEBUG_KEEP_SCREEN_ON) &#123;874 Slog.d(TAG_KEEP_SCREEN_ON, \"handleNotObscuredLocked w: \" + w875 + \", w.mHasSurface: \" + w.mHasSurface876 + \", w.isOnScreen(): \" + onScreen877 + \", w.isDisplayedLw(): \" + w.isDisplayedLw()878 + \", w.mAttrs.userActivityTimeout: \" + w.mAttrs.userActivityTimeout);879 &#125;880 if (w.mHasSurface &amp;&amp; onScreen) &#123;881 if (!syswin &amp;&amp; w.mAttrs.userActivityTimeout &gt;= 0 &amp;&amp; mUserActivityTimeout &lt; 0) &#123;882 mUserActivityTimeout = w.mAttrs.userActivityTimeout;883 if (DEBUG_KEEP_SCREEN_ON) &#123;884 Slog.d(TAG, \"mUserActivityTimeout set to \" + mUserActivityTimeout);885 &#125;886 &#125;887 &#125;888 if (w.mHasSurface &amp;&amp; canBeSeen) &#123;889 if ((attrFlags &amp; FLAG_KEEP_SCREEN_ON) != 0) &#123;890 mHoldScreen = w.mSession;891 mHoldScreenWindow = w;892 &#125; else if (DEBUG_KEEP_SCREEN_ON &amp;&amp; w == mWmService.mLastWakeLockHoldingWindow) &#123;893 Slog.d(TAG_KEEP_SCREEN_ON, \"handleNotObscuredLocked: \" + w + \" was holding \"894 + \"screen wakelock but no longer has FLAG_KEEP_SCREEN_ON!!! called by\"895 + Debug.getCallers(10));896 &#125;897 if (!syswin &amp;&amp; w.mAttrs.screenBrightness &gt;= 0 &amp;&amp; mScreenBrightness &lt; 0) &#123;898 mScreenBrightness = w.mAttrs.screenBrightness;899 &#125;900901 final int type = attrs.type;902 // This function assumes that the contents of the default display are processed first903 // before secondary displays.904 final DisplayContent displayContent = w.getDisplayContent();905 if (displayContent != null &amp;&amp; displayContent.isDefaultDisplay) &#123;906 // While a dream or keyguard is showing, obscure ordinary application content on907 // secondary displays (by forcibly enabling mirroring unless there is other content908 // we want to show) but still allow opaque keyguard dialogs to be shown.909 if (type == TYPE_DREAM || (attrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0) &#123;910 mObscureApplicationContentOnSecondaryDisplays = true;911 &#125;912 displayHasContent = true;913 &#125; else if (displayContent != null &amp;&amp;914 (!mObscureApplicationContentOnSecondaryDisplays915 || (obscured &amp;&amp; type == TYPE_KEYGUARD_DIALOG))) &#123;916 // Allow full screen keyguard presentation dialogs to be seen.917 displayHasContent = true;918 &#125;919 if ((privateflags &amp; PRIVATE_FLAG_SUSTAINED_PERFORMANCE_MODE) != 0) &#123;920 mSustainedPerformanceModeCurrent = true;921 &#125;922 &#125;923924 return displayHasContent;925 &#125; ​ RootWindowContainer.handleNotObscuredLocked返回true的条件有以下： ​ 1.WindowState.mHasSurface且canBeSeen，也就是这个窗口至少已经是申请到layer buffer的。 ​ 2.w.getDisplayContent()非空，一般成立。default display必然为true。 ​ 3.副显且mObscureApplicationContentOnSecondaryDisplays为false(默认就是false)。 ​ 也就是说，正常走到这里面来时，大概率是返回true，但我们不要忽略一个条件，就是这个DisplayContent上必须要有WindowState(mApplySurfaceChangesTransaction是在forAllWindows中才会被执行)。只有往副显上注册窗口才会使副显有自己的内容。","tags":[{"name":"display input AMS WMS SurfaceFlinger","slug":"display-input-AMS-WMS-SurfaceFlinger","permalink":"https://chongyuzhao.github.io/tags/display-input-AMS-WMS-SurfaceFlinger/"}]},{"title":"Android-Input子系统专题-InputFlinger(三)之InputDispatcher","date":"2020-07-11T13:51:03.000Z","path":"2020/07/11/input/Android-Input子系统专题-InputFlinger(三)之InputDispatcher/","text":"​ InputDispatcher是InputFlinger的另一个核心，我们这篇则围绕这个核心来看看InputFlinger是如何分发事件的。 ​ 本篇围绕下面3个问题展开： ​ 1.分发事件的来源是哪里。 ​ 2.事件分发给谁。 ​ 2.使用什么方式分发。 ​ 弄清楚这三个问题，那么InputDispatcher也就弄明白了。 InputDispatcher的运行​ InputDispatcher与InputReader一样，在InputFlinger这个服务启动时就创建的一个线程，我们从线程的loop方法开看它的整体运行过程： 12345678910111213141516171819202122232425// frameworks/native/services/inputflinger/InputDispatcher.cpp 295 void InputDispatcher::dispatchOnce() &#123; 296 nsecs_t nextWakeupTime = LONG_LONG_MAX; 297 &#123; // acquire lock 298 std::scoped_lock _l(mLock); 299 mDispatcherIsAlive.notify_all(); 300 301 // Run a dispatch loop if there are no pending commands. 302 // The dispatch loop might enqueue commands to run afterwards. 303 if (!haveCommandsLocked()) &#123; 304 dispatchOnceInnerLocked(&amp;nextWakeupTime); 305 &#125; 306 307 // Run all pending commands if there are any. 308 // If any commands were run then force the next poll to wake up immediately. 309 if (runCommandsLockedInterruptible()) &#123; 310 nextWakeupTime = LONG_LONG_MIN; 311 &#125; 312 &#125; // release lock 313 314 // Wait for callback or timeout or wake. (make sure we round up, not down) 315 nsecs_t currentTime = now(); 316 int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); 317 mLooper-&gt;pollOnce(timeoutMillis); 318 &#125; ​ 局部变量nextWakeupTime是下一次等待的时间。haveCommandsLocked是判断命令队列是否为空。dispatchOnceInnerLocked是分发一次事件的方法。runCommandsLockedInterruptible是执行一次command。最后调用Looper::pollOnce等待新的唤醒或者如果nextWakeupTime小于0会立即进入下一次loop。InputDispatcher的looper中主要就是处理命令和事件分发。 command的enqueue和run​ InputDispatcher的command是由mCommandQueue来管理，haveCommandsLocked则判断mCommandQueue是否为空，如果非空，那么就优先处理command。command是通过postCommandLocked来进行enqueue的： 123456645 typedef void (InputDispatcher::*Command)(CommandEntry* commandEntry);714 InputDispatcher::CommandEntry* InputDispatcher::postCommandLocked(Command command) &#123;715 CommandEntry* commandEntry = new CommandEntry(command);716 mCommandQueue.enqueueAtTail(commandEntry);717 return commandEntry;718 &#125; ​ Command类型是一个只有一个CommandEntry*参数，返回值为void的函数指针，然后将函数指针封装成CommandEntry： 12345678910111213141516171819648 struct CommandEntry : Link&lt;CommandEntry&gt; &#123;649 explicit CommandEntry(Command command);650 ~CommandEntry();651652 Command command;653654 // parameters for the command (usage varies by command)655 sp&lt;Connection&gt; connection;656 nsecs_t eventTime;657 KeyEntry* keyEntry;658 sp&lt;InputApplicationHandle&gt; inputApplicationHandle;659 std::string reason;660 int32_t userActivityEventType;661 uint32_t seq;662 bool handled;663 sp&lt;InputChannel&gt; inputChannel;664 sp&lt;IBinder&gt; oldToken;665 sp&lt;IBinder&gt; newToken;666 &#125;; ​ postCommandLocked返回的是CommandEntry的指针，而这个函数的传参只有Command这个参数，也就是说调用处需要自己填充CommandEntry，不同的命令传递不同的参数，如下： 1234567891011121314151617184087 void InputDispatcher::onFocusChangedLocked(const sp&lt;InputWindowHandle&gt;&amp; oldFocus,4088 const sp&lt;InputWindowHandle&gt;&amp; newFocus) &#123;4089 sp&lt;IBinder&gt; oldToken = oldFocus != nullptr ? oldFocus-&gt;getToken() : nullptr;4090 sp&lt;IBinder&gt; newToken = newFocus != nullptr ? newFocus-&gt;getToken() : nullptr;4091 CommandEntry* commandEntry = postCommandLocked(4092 &amp; InputDispatcher::doNotifyFocusChangedLockedInterruptible);4093 commandEntry-&gt;oldToken = oldToken;4094 commandEntry-&gt;newToken = newToken;4095 &#125;4067 void InputDispatcher::onDispatchCycleFinishedLocked(4068 nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, uint32_t seq, bool handled) &#123;4069 CommandEntry* commandEntry = postCommandLocked(4070 &amp; InputDispatcher::doDispatchCycleFinishedLockedInterruptible);4071 commandEntry-&gt;connection = connection;4072 commandEntry-&gt;eventTime = currentTime;4073 commandEntry-&gt;seq = seq;4074 commandEntry-&gt;handled = handled;4075 &#125; ​ FocusWindow发生变化时，会enqueue一个doNotifyFocusChangedLockedInterruptible的命令，传递的参数就是新旧FocusWindow的token。而当事件分发结束后就会enqueue一个doDispatchCycleFinishedLockedInterruptible命令，传递这个事件对应的seq、finish事件、handled(是否被处理)和事件分发的对应connection。 Event的接收与分发​ InputDispatcher的主要作用并不是处理command，而是分发事件。InputDispatcher处理Event实际上是分了两部，第一个是接收InputReader组织好的Event，第二就是将这些Event分发给对应的接收者。 Event的接收​ 我们先来看一下dispatchOnceInnerLocked从mInboundQueue队列中取出事件，mInboundQueue的enqueue操作只在enqueueInboundEventLocked方法中调用，也就是所有的enqueue事件的操作都是经过enqueueInboundEventLocked这个方法，在InputFlinger中搜索enqueueInboundEventLocked，可以看到只有5处地方： ​ 1.notifyConfigurationChanged ​ 2.notifyKey，KeyEvent上报。 ​ 3.notifyMotion，MotionEvent上报。 ​ 4.notifyDeviceReset ​ 5.injectInputEvent，测试/input命令注射的Event通路。 ​ 我们以简单的notifyKey这条通路看一下是如何从InputReader enqueue事件的： ​ 上图就是InputReader往InputDispatcher enqueue事件的通路，这算是对InputReader部分知识的补充。从上图可以看到，InputReader从设备节点中读取到事件后，经过InputDevice对应InputMapper(在这里就是KeyboardInputMapper)的处理后，通过调用notifyKey(触摸/鼠标等则调用notifyMotion)接口将Event封装成NotifyArgs的子类push到InputListener的mArgsQueue中。等到InputReader处理完一次loopOnce时，通过调用InputListener.flush将mArgsQueue中所有的事件enqueue到InputDispatcher中。 ​ 为什么要怎么做呢？我认为主要的原因是：高度模块化，InputReader与InputDispatcher是两个不同功能的模块，从bp文件中也可以看到，InputReader、InputDispatcher和InputListener分别是3个动态库的核心文件，这三者职责单一，耦合度低，便于维护和开发。 ​ Event的接收过程还是比较简单的，下面我们关注一下几个小细节。 InputDispatcher线程的wake​ 在InputDispatcher的dispatchOnce方法中，方法的结束时调用了Looper的pollOnce方法，传递了一个next唤醒的timeout时间，最大值为LONG_LONG_MAX，也就是无限等待。那么当timeout为LONG_LONG_MAX时，当然也不是真正的无限休眠了，当接收到事件后也会去唤醒InputDispatcher线程: 1234567891011121314151617181920212223242526272676 void InputDispatcher::notifyKey(const NotifyKeyArgs* args) &#123; ……2720 bool needWake;2721 &#123; // acquire lock2722 mLock.lock(); ……2740 needWake = enqueueInboundEventLocked(newEntry);2741 mLock.unlock();2742 &#125; // release lock27432744 if (needWake) &#123;2745 mLooper-&gt;wake();2746 &#125;2747 &#125;2753 void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) &#123;2795 bool needWake;2796 &#123; // acquire lock2797 mLock.lock(); ……2826 needWake = enqueueInboundEventLocked(newEntry);2827 mLock.unlock();2828 &#125; // release lock28292830 if (needWake) &#123;2831 mLooper-&gt;wake();2832 &#125;2833 &#125; ​ 如代码所示，执行enqueueInboundEventLocked后如果返回true，则调用Looper的wake方法唤醒等待。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859473 bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;474 bool needWake = mInboundQueue.isEmpty();475 mInboundQueue.enqueueAtTail(entry);476 traceInboundQueueLengthLocked();477478 switch (entry-&gt;type) &#123;479 case EventEntry::TYPE_KEY: &#123;480 // Optimize app switch latency.481 // If the application takes too long to catch up then we drop all events preceding482 // the app switch key.483 KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(entry);484 if (isAppSwitchKeyEvent(keyEntry)) &#123;485 if (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123;486 mAppSwitchSawKeyDown = true;487 &#125; else if (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123;488 if (mAppSwitchSawKeyDown) &#123;489 #if DEBUG_APP_SWITCH490 ALOGD(\"App switch is pending!\");491 #endif492 mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT;493 mAppSwitchSawKeyDown = false;494 needWake = true;495 &#125;496 &#125;497 &#125;498 break;499 &#125;500501 case EventEntry::TYPE_MOTION: &#123;502 // Optimize case where the current application is unresponsive and the user503 // decides to touch a window in a different application.504 // If the application takes too long to catch up then we drop all events preceding505 // the touch into the other window.506 MotionEntry* motionEntry = static_cast&lt;MotionEntry*&gt;(entry);507 if (motionEntry-&gt;action == AMOTION_EVENT_ACTION_DOWN508 &amp;&amp; (motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)509 &amp;&amp; mInputTargetWaitCause == INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY510 &amp;&amp; mInputTargetWaitApplicationToken != nullptr) &#123;511 int32_t displayId = motionEntry-&gt;displayId;512 int32_t x = int32_t(motionEntry-&gt;pointerCoords[0].513 getAxisValue(AMOTION_EVENT_AXIS_X));514 int32_t y = int32_t(motionEntry-&gt;pointerCoords[0].515 getAxisValue(AMOTION_EVENT_AXIS_Y));516 sp&lt;InputWindowHandle&gt; touchedWindowHandle = findTouchedWindowAtLocked(displayId, x, y);517 if (touchedWindowHandle != nullptr518 &amp;&amp; touchedWindowHandle-&gt;getApplicationToken()519 != mInputTargetWaitApplicationToken) &#123;520 // User touched a different application than the one we are waiting on.521 // Flag the event, and start pruning the input queue.522 mNextUnblockedEvent = motionEntry;523 needWake = true;524 &#125;525 &#125;526 break;527 &#125;528 &#125;529530 return needWake;531 &#125; ​ enqueueInboundEventLocked方法不仅仅将event equeue到InputDispatcher的mInboundQueue队列中，如果mInboundQueue中原本是NULL，那么线程可能在wait了，因此返回值必然为true，而KeyEvent和MotionEvent则分别做一些判断： ​ KeyEvent，如果是home、endcall和app_switch三种按键且是UP事件，那么就要唤醒(理由是？)。 ​ MotionEvent，如果当前焦点窗口暂未准备好处理事件且对应的Application token不是NULL，然后主触摸点所在的位置不是等待的窗口区域，则唤醒。 Event的分发​ InputDispatcher从名字上来看，就知道其主要功能就是分发事件。下面我们专门看以下InputDispatcher是如何将事件分发到对应的应用中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129320 void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123;321 nsecs_t currentTime = now(); ……346 // Ready to start a new event.347 // If we don't already have a pending event, go grab one.348 if (! mPendingEvent) &#123;349 if (mInboundQueue.isEmpty()) &#123;350 if (isAppSwitchDue) &#123;351 // The inbound queue is empty so the app switch key we were waiting352 // for will never arrive. Stop waiting for it.353 resetPendingAppSwitchLocked(false);354 isAppSwitchDue = false;355 &#125;356357 // Synthesize a key repeat if appropriate.358 if (mKeyRepeatState.lastKeyEntry) &#123;359 if (currentTime &gt;= mKeyRepeatState.nextRepemAppSwitchSawKeyDownatTime) &#123;360 mPendingEvent = synthesizeKeyRepeatLocked(currentTime);361 &#125; else &#123;362 if (mKeyRepeatState.nextRepeatTime &lt; *nextWakeupTime) &#123;363 *nextWakeupTime = mKeyRepeatState.nextRepeatTime;364 &#125;365 &#125;366 &#125;367368 // Nothing to do if there is no pending event.369 if (!mPendingEvent) &#123;370 return;371 &#125;372 &#125; else &#123;373 // Inbound queue has at least one entry.374 mPendingEvent = mInboundQueue.dequeueAtHead();375 traceInboundQueueLengthLocked();376 &#125;377378 // Poke user activity for this event.379 if (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;380 pokeUserActivityLocked(mPendingEvent);381 &#125;382383 // Get ready to dispatch the event.384 resetANRTimeoutsLocked();385 &#125;386387 // Now we have an event to dispatch.388 // All events are eventually dequeued and processed this way, even if we intend to drop them.389 ALOG_ASSERT(mPendingEvent != nullptr);390 bool done = false;391 DropReason dropReason = DROP_REASON_NOT_DROPPED;392 if (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123;393 dropReason = DROP_REASON_POLICY;394 &#125; else if (!mDispatchEnabled) &#123;395 dropReason = DROP_REASON_DISABLED;396 &#125;397398 if (mNextUnblockedEvent == mPendingEvent) &#123;399 mNextUnblockedEvent = nullptr;400 &#125;401402 switch (mPendingEvent-&gt;type) &#123;403 case EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;404 ConfigurationChangedEntry* typedEntry =405 static_cast&lt;ConfigurationChangedEntry*&gt;(mPendingEvent);406 done = dispatchConfigurationChangedLocked(currentTime, typedEntry);407 dropReason = DROP_REASON_NOT_DROPPED; // configuration changes are never dropped408 break;409 &#125;410411 case EventEntry::TYPE_DEVICE_RESET: &#123;412 DeviceResetEntry* typedEntry =413 static_cast&lt;DeviceResetEntry*&gt;(mPendingEvent);414 done = dispatchDeviceResetLocked(currentTime, typedEntry);415 dropReason = DROP_REASON_NOT_DROPPED; // device resets are never dropped416 break;417 &#125;418419 case EventEntry::TYPE_KEY: &#123;420 KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent);421 if (isAppSwitchDue) &#123;422 if (isAppSwitchKeyEvent(typedEntry)) &#123;423 resetPendingAppSwitchLocked(true);424 isAppSwitchDue = false;425 &#125; else if (dropReason == DROP_REASON_NOT_DROPPED) &#123;426 dropReason = DROP_REASON_APP_SWITCH;427 &#125;428 &#125;429 if (dropReason == DROP_REASON_NOT_DROPPED430 &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123;431 dropReason = DROP_REASON_STALE;432 &#125;433 if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;434 dropReason = DROP_REASON_BLOCKED;435 &#125;436 done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);437 break;438 &#125;439440 case EventEntry::TYPE_MOTION: &#123;441 MotionEntry* typedEntry = static_cast&lt;MotionEntry*&gt;(mPendingEvent);442 if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;443 dropReason = DROP_REASON_APP_SWITCH;444 &#125;445 if (dropReason == DROP_REASON_NOT_DROPPED446 &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123;447 dropReason = DROP_REASON_STALE;448 &#125;449 if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;450 dropReason = DROP_REASON_BLOCKED;451 &#125;452 done = dispatchMotionLocked(currentTime, typedEntry,453 &amp;dropReason, nextWakeupTime);454 break;455 &#125;456457 default:458 ALOG_ASSERT(false);459 break;460 &#125;461462 if (done) &#123;463 if (dropReason != DROP_REASON_NOT_DROPPED) &#123;464 dropInboundEventLocked(mPendingEvent, dropReason);465 &#125;466 mLastDropReason = dropReason;467468 releasePendingEventLocked();469 *nextWakeupTime = LONG_LONG_MIN; // force next poll to wake up immediately470 &#125;471 &#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"input","slug":"input","permalink":"https://chongyuzhao.github.io/tags/input/"}]},{"title":"Android-Input子系统专题-InputFlinger(二)之InputReader","date":"2020-03-26T13:25:56.000Z","path":"2020/03/26/input/Android-Input子系统专题-InputFlinger(二)之InputReader/","text":"​ 从InputFlinger的启动篇我们可以知道，InputReader是InputFlinger的核心之一，我们这一篇就围绕这InputReader进行分析研究。 ​ InputReader从名字上来看，就知道InputReader的主要作用就是读取Input事件，这个Input事件包括设备的插拔事件、设备的上报事件。本文档主要就从这两种事件的读取和处理过程进行学习。 InputReader的运行 ​ 我们在InputFlinger那一篇文章中有提到过InputReader的创建： 1234522 sp&lt;InputReaderInterface&gt; createInputReader(23 const sp&lt;InputReaderPolicyInterface&gt;&amp; policy,24 const sp&lt;InputListenerInterface&gt;&amp; listener) &#123;25 return new InputReader(new EventHub(), policy, listener);26 &#125; ​ InputReader接收3个参数，第一个是EventHub，EventHub-事件中心，也就是InputReader读取事件的核心。第二个是policy，是NativeInputManager的对象，也是与客户端通信的代理。第三个是listener，是InputClassifer的对象。这三个参数在InputReader的运行提供了什么作用，我们继续分析。 refreshConfigurationLocked​ 在InputReader构造的过程中，InputReader会先去获取系统的配置(2.refreshConfigurationLocked)： 123456789101112131415161718557 void InputReader::refreshConfigurationLocked(uint32_t changes) &#123;558 mPolicy-&gt;getReaderConfiguration(&amp;mConfig);559 mEventHub-&gt;setExcludedDevices(mConfig.excludedDeviceNames);560561 if (changes) &#123;562 ALOGI(\"Reconfiguring input devices. changes=0x%08x\", changes);563 nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);564565 if (changes &amp; InputReaderConfiguration::CHANGE_MUST_REOPEN) &#123;566 mEventHub-&gt;requestReopenDevices();567 &#125; else &#123;568 for (size_t i = 0; i &lt; mDevices.size(); i++) &#123;569 InputDevice* device = mDevices.valueAt(i);570 device-&gt;configure(now, &amp;mConfig, changes);571 &#125;572 &#125;573 &#125;574 &#125; ​ changes传进来的值为0，也就是是只执行了两个操作，分别是getReaderConfiguration和setExcludedDevices。这两个操作我们先记一下，后续还会用到。 loopOnce​ InputReader是依赖于InputReaderThread来运行的： 123445 bool InputReaderThread::threadLoop() &#123;46 mReader-&gt;loopOnce();47 return true;48 &#125; ​ 作为一个子线程，InputReaderThread就是在不断地去运行InputReader的loopOnce。下面就是InputReader一次循环所做的事： ​ 1.如果InputReader的配置发生变化，调用refreshConfigurationLocked去通知所有相关的对象做出处理。 ​ 2.调用mEventHub.getEvents去获取事件(6.getEvents) ​ 3.处理获取的事件，包括设备插拔事件和上报事件(7.processEventsLocked) ​ 4.如果Inpt设备发生变化(拔插事件)，那么通过NativeInputManager去通知上层服务(8.notifyInputDevicesChanged)。 ​ 5.调用QueuedInputListener的对象去通知注册的监听者，做出相关的处理。 ​ InputReader就是不断地重复这个操作，读取事件，处理事件，通知系统接收处理事件。下面也继续根据这三个步骤去看看InputReader的机理。 InputReader读取事件​ EventHub在构建的时候，会通过inotify机制去监听特定目录下的文件变动(包括文件的创建、删除和内容更新)，然后将这个inotify的fd添加到epoll的监听队列中。并且创建了一个pipe，用在线程间的唤醒： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556245 EventHub::EventHub(void) : 246 mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(1), mControllerNumbers(), 247 mOpeningDevices(nullptr), mClosingDevices(nullptr), 248 mNeedToSendFinishedDeviceScan(false), 249 mNeedToReopenDevices(false), mNeedToScanDevices(true), 250 mPendingEventCount(0), mPendingEventIndex(0), mPendingINotify(false) &#123; 251 acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID); 252 253 mEpollFd = epoll_create1(EPOLL_CLOEXEC); 254 LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance: %s\", strerror(errno)); 255 256 mINotifyFd = inotify_init(); 257 mInputWd = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE); 258 LOG_ALWAYS_FATAL_IF(mInputWd &lt; 0, \"Could not register INotify for %s: %s\", 259 DEVICE_PATH, strerror(errno)); 260 if (isV4lScanningEnabled()) &#123; 261 mVideoWd = inotify_add_watch(mINotifyFd, VIDEO_DEVICE_PATH, IN_DELETE | IN_CREATE); 262 LOG_ALWAYS_FATAL_IF(mVideoWd &lt; 0, \"Could not register INotify for %s: %s\", 263 VIDEO_DEVICE_PATH, strerror(errno)); 264 &#125; else &#123; 265 mVideoWd = -1; 266 ALOGI(\"Video device scanning disabled\"); 267 &#125; 268 269 struct epoll_event eventItem; 270 memset(&amp;eventItem, 0, sizeof(eventItem)); 271 eventItem.events = EPOLLIN; 272 eventItem.data.fd = mINotifyFd; 273 int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem); 274 LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add INotify to epoll instance. errno=%d\", errno); 275 276 int wakeFds[2]; 277 result = pipe(wakeFds); 278 LOG_ALWAYS_FATAL_IF(result != 0, \"Could not create wake pipe. errno=%d\", errno); 279 280 mWakeReadPipeFd = wakeFds[0]; 281 mWakeWritePipeFd = wakeFds[1]; 282 283 result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK); 284 LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake read pipe non-blocking. errno=%d\", 285 errno); 286 287 result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK); 288 LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake write pipe non-blocking. errno=%d\", 289 errno); 290 291 eventItem.data.fd = mWakeReadPipeFd; 292 result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem); 293 LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake read pipe to epoll instance. errno=%d\", 294 errno); 295 296 int major, minor; 297 getLinuxRelease(&amp;major, &amp;minor); 298 // EPOLLWAKEUP was introduced in kernel 3.5 299 mUsingEpollWakeup = major &gt; 3 || (major == 3 &amp;&amp; minor &gt;= 5); 300 &#125; EventHub.getEvents​ EventHub，事件中心，也是系统Input事件的采集器，InputReader就是通过它不断地读取事件。由于getEvents的源码比较长，而且不直观，因此我用以下的思维导图展示getEvents的整个流程： ​ 在看getEvents的过程前，先说一下几个变量的初始值： 123456mNeedToReopenDevices = false;mNeedToScanDevices = true;mNeedToSendFinishedDeviceScan = false;mPendingEventIndex = 0;mPendingEventCount = 0;mPendingINotify = false; ​ 为什么要先说一下以上几个变量的初始值呢，因为getEvents的过程就像是一个不断迭代的操作，那么第一次运行的状态如果没有初始值，是无法控制的。 ​ 1.mNeedToReopenDevices的值默认是false，只有当InputReader收到CHANGE_MUST_REOPEN的请求后才会被执行： 123456789557 void InputReader::refreshConfigurationLocked(uint32_t changes) &#123; ……565 if (changes &amp; InputReaderConfiguration::CHANGE_MUST_REOPEN) &#123;566 mEventHub-&gt;requestReopenDevices();567 &#125; else &#123; ……572 &#125;573 &#125;574 &#125; mNeedToReopenDevices为true，那么就会先关闭所有的设备，设置mNeedToScanDevices = true，在后面重新扫描所有的输入设备。 2.当mClosingDevices列表中存在需要关闭的设备，那么就会生成一个DEVICE_REMOVED类型的事件，在processEventLocked去处理，mClosingDevices的值就是从closeDeviceLocked()中设置。 ​ 3.mNeedToScanDevices的值为true，那么就会去扫描所有的设备，它的值为true只有两种情况，EventHub初始化的时候和InputReader收到CHANGE_MUST_REOPEN的请求。后者在第一点的时候已经看到了，前者很好理解，当EventHub初始化的时候，可能有些设备注册好了(编辑进内核的驱动会先执行完再启动Android的)，因此在进程启动的前期就需要将这个设备进行处理，否者后面的监听是没有意义的。 ​ 4.当mOpeningDevices列表中有需要打开的设备，那么就会封装一个DEVICE_ADDED类型的事件，在`processEventLocked中处理。 ​ 5.如果mNeedToSendFinishedDeviceScan == true,那么就会封装一个FINISHED_DEVICE_SCAN类型的事件。 ​ 6.后面就是处理我们所读取到的事件了，EventHub刚启动的第一次是没有进行事件的读取的，因此第一次是不会走到这一步中，但后面会阻塞在read调用中，等待事件的发生，这些事件又分为五类：①mINotifyFd，从前面EventHub的构建我们可以知道，这个是监听&quot;/dev/input&quot;目录的变动，包括EPOLLIN(有新的节点创建/删除)和其他的事件(参考epoll的事件类型)。而在这里，只对EPOLLIN类型事件做了处理。②mWakeReadPipeFd，也就是说其他的线程通过mWakeWritePipeFd写东西，作用就是唤醒InputReaderThread，因为InputReaderThread会调用read这个syscall进入阻塞状态，如果一直没有事件发生，会响应不到外界的消息的，如InputReaderConfiguration的变化等。这个节点的作用主要是唤醒，因此没有对它的内容进行处理的。③videoDevice设备的节点，暂时没有对其研究过，后续再研究，但与其他的输入设备事件是类似的，只是对与这类特殊的设备做了特殊的处理而已。④普通输入设备的EPOLLIN类型事件，说明了节点有新的内容，通过read系统调用，如果读取不到内容或者失败，那么设备节点异常，可能已经被移除了，因此关闭设备，否则就应该是输入事件，将输入事件的数据封装成RawEvent对象等待处理。⑤普通输入设备的EPOLLHUP，直接去关闭设备。 ​ 7.这步的操作是完成第6点的第①小点未尽之事，当mINotifyFd的EPOLLIN发生，那么就有可能走到这一步，但这个并不一定是立即执行，因为还有一个条件 – mPendingEventIndex &gt;= mPendingEventCount，这是什么意思呢？这个条件只有在前面的while循环中，将上一轮读取到的事件都按部就班处理了之后再处理新的输入设备节点生成的事件。这部分的逻辑在代码中的注释已经写明：readNotify()方法有可能会导致输入设备列表的变动，这个变动主要是设备被移除，但这种情况有可能出现在PendingEvent还没处理完，然后再次getEvents的时候，设备已经被移除，这时如果先处理了设备移除的事件，那么PendingEvents中有该设备未处理完的事件，就会出现异常了(因为InputDevice都被释放了)。因此放在处理完所有的PendingEvents后再处理。 ​ 8.如果deviceChanged == true，即前面的步骤检测到了设备节点的变动，那么就优先去处理这些设备的变动，这主要就是上面的第2和第4点。 ​ 9.event != buffer || awoken，即前面已经收集需要处理的事件了，或者被其他线程唤醒了，需要去处理，那么就会跳过其他的步骤，直接返回。 ​ 10.重置状态，使用epoll_wait去监听事件。 ​ 以上就是EventHub.getEvents所做的工作，下面我们看一下一些细节的东西。 scanDevicesLocked​ 从上面的第3点中知道，EventHub在初始话后的第一次运行，会先扫描所有的设备： 1234567891011121314151082 void EventHub::scanDevicesLocked() &#123;1083 status_t result = scanDirLocked(DEVICE_PATH);1084 if(result &lt; 0) &#123;1085 ALOGE(\"scan dir failed for %s\", DEVICE_PATH);1086 &#125;1087 if (isV4lScanningEnabled()) &#123;1088 result = scanVideoDirLocked(VIDEO_DEVICE_PATH);1089 if (result != OK) &#123;1090 ALOGE(\"scan video dir failed for %s\", VIDEO_DEVICE_PATH);1091 &#125;1092 &#125;1093 if (mDevices.indexOfKey(ReservedInputDeviceId::VIRTUAL_KEYBOARD_ID) &lt; 0) &#123;1094 createVirtualKeyboardLocked();1095 &#125;1096 &#125; ​ *DEVICE_PATH = &quot;/dev/input&quot;，/dev/input下的设备是InputFlinger所监听的主体： 12345678910111213141516171819202122231860 status_t EventHub::scanDirLocked(const char *dirname)1861 &#123;1862 char devname[PATH_MAX];1863 char *filename;1864 DIR *dir;1865 struct dirent *de;1866 dir = opendir(dirname);1867 if(dir == nullptr)1868 return -1;1869 strcpy(devname, dirname);1870 filename = devname + strlen(devname);1871 *filename++ = '/';1872 while((de = readdir(dir))) &#123;1873 if(de-&gt;d_name[0] == '.' &amp;&amp;1874 (de-&gt;d_name[1] == '\\0' ||1875 (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2] == '\\0')))1876 continue;1877 strcpy(filename, de-&gt;d_name);1878 openDeviceLocked(devname);1879 &#125;1880 closedir(dir);1881 return 0;1882 &#125; ​ openDeviceLocked的代码很长，我们这里就不贴上来，继续使用思维导图的方式展示代码： ​ openDeviceLocked主要是为新的设备创建Device对象，并加入到管理队列中，然后从驱动中获取相关的信息，如Bitmask(设备支持哪些类型的事件)，判断设备是否在ExcludedDeviceList(mExcludedDevices)中，这个是由/vendor/etc/excluded-input-devices.xml或/system/etc/excluded-input-devices.xml下所定义的。有兴趣可以自行追溯代码，如果设备名在这个表中，那么就是InputFlinger不会注册这个设备。 ​ 然后就是填充Device这个对象，并将设备节点的fd注册到epoll监听队列中，后面EventHub.getEvents就可以监听接收设备上报的事件了。configureFd主要是配置驱动的时钟，也就是上报事件的时间戳的基准，默认是realtime，也就是距离1980年的时间，因此需要修改一下。 ​ 最后就是addDeviceLocked，这个就是将新建的设备加入到mDevices，设置为mOpeningDevices，后面就继续被处理。 readNotifyLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491810 status_t EventHub::readNotifyLocked() &#123;1811 int res;1812 char event_buf[512];1813 int event_size;1814 int event_pos = 0;1815 struct inotify_event *event;18161817 ALOGV(\"EventHub::readNotify nfd: %d\\n\", mINotifyFd);1818 res = read(mINotifyFd, event_buf, sizeof(event_buf));1819 if(res &lt; (int)sizeof(*event)) &#123;1820 if(errno == EINTR)1821 return 0;1822 ALOGW(\"could not get event, %s\\n\", strerror(errno));1823 return -1;1824 &#125;18251826 while(res &gt;= (int)sizeof(*event)) &#123;1827 event = (struct inotify_event *)(event_buf + event_pos);1828 if(event-&gt;len) &#123;1829 if (event-&gt;wd == mInputWd) &#123;1830 std::string filename = StringPrintf(\"%s/%s\", DEVICE_PATH, event-&gt;name);1831 if(event-&gt;mask &amp; IN_CREATE) &#123;1832 openDeviceLocked(filename.c_str());1833 &#125; else &#123;1834 ALOGI(\"Removing device '%s' due to inotify event\\n\", filename.c_str());1835 closeDeviceByPathLocked(filename.c_str());1836 &#125;1837 &#125;1838 else if (event-&gt;wd == mVideoWd) &#123;1839 if (isV4lTouchNode(event-&gt;name)) &#123;1840 std::string filename = StringPrintf(\"%s/%s\", VIDEO_DEVICE_PATH, event-&gt;name);1841 if (event-&gt;mask &amp; IN_CREATE) &#123;1842 openVideoDeviceLocked(filename);1843 &#125; else &#123;1844 ALOGI(\"Removing video device '%s' due to inotify event\", filename.c_str());1845 closeVideoDeviceByPathLocked(filename);1846 &#125;1847 &#125;1848 &#125;1849 else &#123;1850 LOG_ALWAYS_FATAL(\"Unexpected inotify event, wd = %i\", event-&gt;wd);1851 &#125;1852 &#125;1853 event_size = sizeof(*event) + event-&gt;len;1854 res -= event_size;1855 event_pos += event_size;1856 &#125;1857 return 0;1858 &#125; ​ readNotifyLocked主要是处理”/dev/input”(如果支持v4l-touch设备，还将监听”/dev”下是否有”v4l-touch”这个节点的变动)的变动情况，如果是IN_CREATE的事件，那么就是有新的节点注册，调用openDeviceLocked去处理，这就是设备的注册，在上一小节有分析过，如果是其他类型的事件，就是设备被拔出，调用closeDeviceByPathLocked去注销设备(针对”/dev/input“目录)。 processEventsLocked​ 经过EventHub的事件收集后，InputReader就会对这些事件进行处理 – processEventsLocked： 12345678910111213141516171819202122232425262728293031323334353637350 void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123;351 for (const RawEvent* rawEvent = rawEvents; count;) &#123;352 int32_t type = rawEvent-&gt;type;353 size_t batchSize = 1;354 if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;355 int32_t deviceId = rawEvent-&gt;deviceId;356 while (batchSize &lt; count) &#123;357 if (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT358 || rawEvent[batchSize].deviceId != deviceId) &#123;359 break;360 &#125;361 batchSize += 1;362 &#125;363 #if DEBUG_RAW_EVENTS364 ALOGD(\"BatchSize: %zu Count: %zu\", batchSize, count);365 #endif366 processEventsForDeviceLocked(deviceId, rawEvent, batchSize);367 &#125; else &#123;368 switch (rawEvent-&gt;type) &#123;369 case EventHubInterface::DEVICE_ADDED:370 addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);371 break;372 case EventHubInterface::DEVICE_REMOVED:373 removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);374 break;375 case EventHubInterface::FINISHED_DEVICE_SCAN:376 handleConfigurationChangedLocked(rawEvent-&gt;when);377 break;378 default:379 ALOG_ASSERT(false); // can't happen380 break;381 &#125;382 &#125;383 count -= batchSize;384 rawEvent += batchSize;385 &#125;386 &#125; ​ processEventsLocked将事件分成了四类进行处理，第一类是type小于FIRST_SYNTHETIC_EVENT类型的事件，也就是input事件，这也是处理最多的事件，也是我们的重点。第二类是DEVICE_ADDED类型事件，也就是设备新增事件。第三类是DEVICE_REMOVED设备删除事件。第四类是FINISHED_DEVICE_SCAN设备扫描结束事件。 addDeviceLocked​ 第一类事件是我们研究的重点核心，因此放到后面单独进行学习，我们先从第二类开始： 123456789101112131415161718192021222324252627282930388 void InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) &#123;389 ssize_t deviceIndex = mDevices.indexOfKey(deviceId);390 if (deviceIndex &gt;= 0) &#123;391 ALOGW(\"Ignoring spurious device added event for deviceId %d.\", deviceId);392 return;393 &#125;394395 InputDeviceIdentifier identifier = mEventHub-&gt;getDeviceIdentifier(deviceId);396 uint32_t classes = mEventHub-&gt;getDeviceClasses(deviceId);397 int32_t controllerNumber = mEventHub-&gt;getDeviceControllerNumber(deviceId);398399 InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);400 device-&gt;configure(when, &amp;mConfig, 0);401 device-&gt;reset(when);402403 if (device-&gt;isIgnored()) &#123;404 ALOGI(\"Device added: id=%d, name='%s' (ignored non-input device)\", deviceId,405 identifier.name.c_str());406 &#125; else &#123;407 ALOGI(\"Device added: id=%d, name='%s', sources=0x%08x\", deviceId,408 identifier.name.c_str(), device-&gt;getSources());409 &#125;410411 mDevices.add(deviceId, device);412 bumpGenerationLocked();413414 if (device-&gt;getClasses() &amp; INPUT_DEVICE_CLASS_EXTERNAL_STYLUS) &#123;415 notifyExternalStylusPresenceChanged();416 &#125;417 &#125; ​ addDeviceLocked的核心就是createDeviceLocked，此处就是构建InputDevice的对象，用于处理各种不同的设备。而这个的关键就是各种各样的InputMapper接口实现，以下就是不同设备对应的InputMapper，而对设备进行分类的地方是在openDeviceLocked中，在前面由于篇幅的问题没有一一展开，而是在这里与createDeviceLocked的创建InputMapper关联起来会更加清晰： ​ 各类设备对于事件的处理都不同，而且从代码中可以知道，设备类型并不仅仅是只支持一类，而是可以多种类型混合的，对于不同的设备处理方式，我们在后续有机会再详细分析，而后面的文档中将会集中分析Android中常用的keyboard类型和touch类型设备事件处理过程。 ​ 第三类DEVICE_REMOVED事件其实就是新增设备的注销过程，我们就不再展开。 handleConfigurationChangedLocked123456789101112 548 void InputReader::handleConfigurationChangedLocked(nsecs_t when) &#123; 549 // Reset global meta state because it depends on the list of all configured devices. 550 updateGlobalMetaStateLocked(); 551 552 // Enqueue configuration changed. 553 NotifyConfigurationChangedArgs args(mContext.getNextSequenceNum(), when); 554 mQueuedListener-&gt;notifyConfigurationChanged(&amp;args); 555 &#125;230 void QueuedInputListener::notifyConfigurationChanged(231 const NotifyConfigurationChangedArgs* args) &#123;232 mArgsQueue.push_back(new NotifyConfigurationChangedArgs(*args));233 &#125; ​ 最终这个处理就是通知到IMS中。这个目前没有怎么接触过，先不详细分析。 processEventsForDeviceLocked​ 除了设备信息的事件外，其他事件都是通过processEventsForDeviceLocked进行处理的，如按键事件(什么key被按下或松开)、触摸坐标等等。 12345678910111213141516522 void InputReader::processEventsForDeviceLocked(int32_t deviceId,523 const RawEvent* rawEvents, size_t count) &#123;524 ssize_t deviceIndex = mDevices.indexOfKey(deviceId);525 if (deviceIndex &lt; 0) &#123;526 ALOGW(\"Discarding event for unknown deviceId %d.\", deviceId);527 return;528 &#125;529530 InputDevice* device = mDevices.valueAt(deviceIndex);531 if (device-&gt;isIgnored()) &#123;532 //ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId);533 return;534 &#125;535536 device-&gt;process(rawEvents, count);537 &#125; ​ 通过rawEvent的deviceId拿到在addDeviceLocked中创建的Device对象(这个部分可以仔细查看源码，这个deviceId在EventHub和InputReader是一样的，而这个deviceId也是跟InputFlinger打开的设备节点fd挂钩)。 1234567891011121314151617181920212223242526272829303132333435361132 void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123;1133 // Process all of the events in order for each mapper.1134 // We cannot simply ask each mapper to process them in bulk because mappers may1135 // have side-effects that must be interleaved. For example, joystick movement events and1136 // gamepad button presses are handled by different mappers but they should be dispatched1137 // in the order received.1138 for (const RawEvent* rawEvent = rawEvents; count != 0; rawEvent++) &#123;1139 #if DEBUG_RAW_EVENTS1140 ALOGD(\"Input event: device=%d type=0x%04x code=0x%04x value=0x%08x when=%\" PRId64,1141 rawEvent-&gt;deviceId, rawEvent-&gt;type, rawEvent-&gt;code, rawEvent-&gt;value,1142 rawEvent-&gt;when);1143 #endif11441145 if (mDropUntilNextSync) &#123;1146 if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;1147 mDropUntilNextSync = false;1148 #if DEBUG_RAW_EVENTS1149 ALOGD(\"Recovered from input event buffer overrun.\");1150 #endif1151 &#125; else &#123;1152 #if DEBUG_RAW_EVENTS1153 ALOGD(\"Dropped input event while waiting for next input sync.\");1154 #endif1155 &#125;1156 &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;1157 ALOGI(\"Detected input event buffer overrun for device %s.\", getName().c_str());1158 mDropUntilNextSync = true;1159 reset(rawEvent-&gt;when);1160 &#125; else &#123;1161 for (InputMapper* mapper : mMappers) &#123;1162 mapper-&gt;process(rawEvent);1163 &#125;1164 &#125;1165 --count;1166 &#125;1167 &#125; ​ 实际处理事件的是InputMapper，不同设备有不同的特性，这些特性可能还会有多个，因此以个Device可以对应有多个InputMapper。然后让这个mapper去根据他们的特性去处理，我们以简单的key来说，在createDeviceLocked的思维导图中，我们知道keyboardsource的设备会创建KeyboardInputMapper。接下来就是不同设备之间的处理方式的不同了，我们就不继续往下分析，在后面的文档中根据需要继续深入分析。 总结​ InputReader的代码是很庞大的，只是在这个版本的代码中将各种各样的InputMapper的具体实现也放入到这里，在AndroidR版本上，InputMapper的代码已经从InputReader中剥离出来，使InputReader的代码更简洁和明了，而实际上InputReader的核心就只有两点： ​ 1.使用EventHub来从Linux的设备节点中监听事件，包括设备的热插拔信息，设备的事件信息等。 ​ 2.根据采集到的事件做相应的处理，包括设备的创建、删除和设备输入事件的处理等。 ​ InputReader认为，所有的输入设备都是一样的，使用InputDevice来进行抽象封装，而不同的设备具有不同的特性，如是按键类型的设备、触摸事件类型的设备、振动器设备等等，或者是他们之中的组合，如触摸板，既有按键也有触摸，而根据这些特性，为这些InputDevice创建对应的InputMapper实例，使具体的输入事件由这些InputMapper来处理。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android多屏幕专题--双Home的启动","date":"2020-03-22T02:54:36.000Z","path":"2020/03/22/Android多屏幕专题-双Home的启动/","text":"Android多屏幕专题 – 双Home的启动​ 在一个偶然的机会下，发现AndroidQ是支持两个Launcher的，在两个显示设备的情况下，可以分别启动两个Launcher，在这两个Launcher中都可以操作，如打开应用，虚拟导航栏等，也就是说，使用这种模式，是可以同时打开两个应用分别操作。 ​ 启动双Home的方式，首先是这个Android系统不能是低内存设备(low ram device)，其次可通过settings put global force_desktop_mode_on_external_displays 1，重启后两个显示器上就有不同的Home了。 ​ 下面我们就来看看这个settings字段是如何控制双Home的启动。前面的代码追溯我们就不一一展开，直接从SystemServer启动完成后就会调用AMS的systemReady方法，而在AMS的systemReady中就会去启动我们的Launcher: 123456789101112131415161718192021 8960 public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) &#123; …… 9076 mAtmInternal.startHomeOnAllDisplays(currentUserId, \"systemReady\"); …… 9136 &#125;6691 @Override6692 public boolean startHomeOnAllDisplays(int userId, String reason) &#123;6693 synchronized (mGlobalLock) &#123;6694 return mRootActivityContainer.startHomeOnAllDisplays(userId, reason);6695 &#125;6696 &#125; 332 boolean startHomeOnAllDisplays(int userId, String reason) &#123; 333 boolean homeStarted = false; 334 for (int i = mActivityDisplays.size() - 1; i &gt;= 0; i--) &#123; 335 final int displayId = mActivityDisplays.get(i).mDisplayId; 336 homeStarted |= startHomeOnDisplay(userId, reason, displayId); 337 &#125; 338 return homeStarted; 339 &#125; startHomeOnDisplay​ mActivityDisplays中记录了启动过程中所注册进来的display，在AMS中，使用ActivityDisplay来描述显示屏，这里的startHomeOnAllDisplays就是去为所有的显示屏去启动一个Home，当然啦，并不是一定会为每个屏幕都启动一个Home. 1234567891011121314151617181920212223242526272829303132333435363738394041424344350 boolean startHomeOnDisplay(int userId, String reason, int displayId) &#123;351 return startHomeOnDisplay(userId, reason, displayId, false /* allowInstrumenting */,352 false /* fromHomeKey */);353 &#125;366 boolean startHomeOnDisplay(int userId, String reason, int displayId, boolean allowInstrumenting,367 boolean fromHomeKey) &#123;368 // Fallback to top focused display if the displayId is invalid.369 if (displayId == INVALID_DISPLAY) &#123;370 displayId = getTopDisplayFocusedStack().mDisplayId;371 &#125;372373 Intent homeIntent = null;374 ActivityInfo aInfo = null;375 if (displayId == DEFAULT_DISPLAY) &#123;376 homeIntent = mService.getHomeIntent();377 aInfo = resolveHomeActivity(userId, homeIntent);378 &#125; else if (shouldPlaceSecondaryHomeOnDisplay(displayId)) &#123;379 Pair&lt;ActivityInfo, Intent&gt; info = resolveSecondaryHomeActivity(userId, displayId);380 aInfo = info.first;381 homeIntent = info.second;382 &#125;383 if (aInfo == null || homeIntent == null) &#123;384 return false;385 &#125;386387 if (!canStartHomeOnDisplay(aInfo, displayId, allowInstrumenting)) &#123;388 return false;389 &#125;390391 // Updates the home component of the intent.392 homeIntent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));393 homeIntent.setFlags(homeIntent.getFlags() | FLAG_ACTIVITY_NEW_TASK);394 // Updates the extra information of the intent.395 if (fromHomeKey) &#123;396 homeIntent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, true);397 &#125;398 // Update the reason for ANR debugging to verify if the user activity is the one that399 // actually launched.400 final String myReason = reason + \":\" + userId + \":\" + UserHandle.getUserId(401 aInfo.applicationInfo.uid) + \":\" + displayId;402 mService.getActivityStartController().startHomeActivity(homeIntent, aInfo, myReason,403 displayId);404 return true;405 &#125; ​ 当displayId等于DEFAULT_DISPLAY，即主显的时候，必然会给其找一个Launcher进行启动。当displayId不是DEFAULT_DISPLAY，即非主显时，就要过三关了： ​ 第一关，系统是否支持SecondaryHomeOnDisplay–shouldPlaceSecondaryHomeOnDisplay，如果系统没有配置打开，那么AMS就不会启动双Home了。 ​ 第二关，系统中有定义SecondaryHomeActivity–resolveSecondaryHomeActivity，如果没有第二个Launcher，那么也就没有可以使用的Activity，AMS根本就没法启动。 ​ 第三关，检查是否允许在对应的display中启动Home–canStartHomeOnDisplay，如果是AMS在启动的时候，是不会有问题的。 shouldPlaceSecondaryHomeOnDisplay​ 先看第一关考验的内容： 12345678910111213141516171819202122232425262728293031323334540 boolean shouldPlaceSecondaryHomeOnDisplay(int displayId) &#123;541 if (displayId == DEFAULT_DISPLAY) &#123;542 throw new IllegalArgumentException(543 \"shouldPlaceSecondaryHomeOnDisplay: Should not be DEFAULT_DISPLAY\");544 &#125; else if (displayId == INVALID_DISPLAY) &#123;545 return false;546 &#125;547548 if (!mService.mSupportsMultiDisplay) &#123;549 // Can't launch home on secondary display if device does not support multi-display.550 return false;551 &#125;552553 final boolean deviceProvisioned = Settings.Global.getInt(554 mService.mContext.getContentResolver(),555 Settings.Global.DEVICE_PROVISIONED, 0) != 0;556 if (!deviceProvisioned) &#123;557 // Can't launch home on secondary display before device is provisioned.558 return false;559 &#125;560561 if (!StorageManager.isUserKeyUnlocked(mCurrentUser)) &#123;562 // Can't launch home on secondary displays if device is still locked.563 return false;564 &#125;565566 final ActivityDisplay display = getActivityDisplay(displayId);567 if (display == null || display.isRemoved() || !display.supportsSystemDecorations()) &#123;568 // Can't launch home on display that doesn't support system decorations.569 return false;570 &#125;571572 return true;573 &#125; ​ mService.mSupportsMultiDisplay是指系统是否支持多屏幕，其决定因素有： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748721 public void retrieveSettings(ContentResolver resolver) &#123;722 final boolean freeformWindowManagement =723 mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)724 || Settings.Global.getInt(725 resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, 0) != 0;726727 final boolean supportsMultiWindow = ActivityTaskManager.supportsMultiWindow(mContext);728 final boolean supportsPictureInPicture = supportsMultiWindow &amp;&amp;729 mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE);730 final boolean supportsSplitScreenMultiWindow =731 ActivityTaskManager.supportsSplitScreenMultiWindow(mContext);732 final boolean supportsMultiDisplay = mContext.getPackageManager()733 .hasSystemFeature(FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);734 final boolean forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, 0) != 0;735 final boolean forceResizable = Settings.Global.getInt(736 resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0;737 final boolean isPc = mContext.getPackageManager().hasSystemFeature(FEATURE_PC);738739 // Transfer any global setting for forcing RTL layout, into a System Property740 DisplayProperties.debug_force_rtl(forceRtl);741742 final Configuration configuration = new Configuration();743 Settings.System.getConfiguration(resolver, configuration);744 if (forceRtl) &#123;745 // This will take care of setting the correct layout direction flags746 configuration.setLayoutDirection(configuration.locale);747 &#125;748749 synchronized (mGlobalLock) &#123;750 mForceResizableActivities = forceResizable;751 final boolean multiWindowFormEnabled = freeformWindowManagement752 || supportsSplitScreenMultiWindow753 || supportsPictureInPicture754 || supportsMultiDisplay;755 if ((supportsMultiWindow || forceResizable) &amp;&amp; multiWindowFormEnabled) &#123;756 mSupportsMultiWindow = true;757 mSupportsFreeformWindowManagement = freeformWindowManagement;758 mSupportsSplitScreenMultiWindow = supportsSplitScreenMultiWindow;759 mSupportsPictureInPicture = supportsPictureInPicture;760 mSupportsMultiDisplay = supportsMultiDisplay;761 &#125; else &#123;762 mSupportsMultiWindow = false;763 mSupportsFreeformWindowManagement = false;764 mSupportsSplitScreenMultiWindow = false;765 mSupportsPictureInPicture = false;766 mSupportsMultiDisplay = false;767 &#125; ……… ​ 从代码中可以看到，supportsMultiDisplay要为true，那么就需要满足以下的条件：①.系统有配置android.software.activities_on_secondary_displays这个feature，如果是LowRam设备，那么在配置中必须要加上notLowRam=false这个属性。②.支持多窗口模式–supportsMultiWindow(此次成立的条件是非LowRam设备或者是watch设备，且配置了config_supportsSplitScreenMultiWindow)或者系统支持窗口大小调整–forceResizable(settings global中设置force_resizable_activities为1).③.使能多窗口模式 – multiWindowFormEnabled，其实这条件在前面的条件成立后，自然也就成立。 ​ 在supportsMultiDisplay为true，后第二步就是要deviceProvisioned为true，这个值是从settings global中获取，而这个值是在开机向导(Provisions)结束后就会设置为true，这条件一般也会成立，我们无需在意。 ​ 第三步就是系统处于非锁屏状态，这也很好理解，当处于锁屏状态，Home是还没起来的。 ​ 第四步就是所传进来的Display是有效的且没有被移除，然后满足isplay.supportsSystemDecorations()返回true： 123456789101209 boolean supportsSystemDecorations() &#123;1210 return mDisplayContent.supportsSystemDecorations();1211 &#125;5023 boolean supportsSystemDecorations() &#123;5024 return (mWmService.mDisplayWindowSettings.shouldShowSystemDecorsLocked(this)5025 || (mDisplay.getFlags() &amp; FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS) != 05026 || (mWmService.mForceDesktopModeOnExternalDisplays &amp;&amp; !isUntrustedVirtualDisplay()))5027 // VR virtual display will be used to run and render 2D app within a VR experience.5028 &amp;&amp; mDisplayId != mWmService.mVr2dDisplayId;5029 &#125; ​ supportsSystemDecorations()返回true满足的条件：①.该Display不是2D的VR屏。②.满足以下条件之一： ​ 一.mWmService.mDisplayWindowSettings.shouldShowSystemDecorsLocked()返回true： 12345678910111213343 boolean shouldShowSystemDecorsLocked(DisplayContent dc) &#123;344 if (dc.getDisplayId() == Display.DEFAULT_DISPLAY) &#123;345 // For default display should show system decors.346 return true;347 &#125;348349 final DisplayInfo displayInfo = dc.getDisplayInfo();350 final Entry entry = getEntry(displayInfo);351 if (entry == null) &#123;352 return false;353 &#125;354 return entry.mShouldShowSystemDecors;355 &#125; ​ 目前从Android的源码中没有看过设置这个值的地方，我们先跳过。 ​ 二.Display具备FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS这个flags，也没有从代码中看到相关的设置，也跳过。 ​ 三.mWmService.mForceDesktopModeOnExternalDisplays为true，且非不可信的虚拟屏，后者一般为true，前者就是我们最开始说的settings put global force_desktop_mode_on_external_displays 1： 1234567 999 private WindowManagerService(Context context, InputManagerService inputManager,1000 boolean showBootMsgs, boolean onlyCore, WindowManagerPolicy policy,1001 ActivityTaskManagerService atm, TransactionFactory transactionFactory) &#123; ……1119 mForceDesktopModeOnExternalDisplays = Settings.Global.getInt(resolver,1120 DEVELOPMENT_FORCE_DESKTOP_MODE_ON_EXTERNAL_DISPLAYS, 0) != 0; …… ​ 至此第一关就闯关成功。 resolveSecondaryHomeActivity​ 第二关就准备开始了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950443 @VisibleForTesting444 Pair&lt;ActivityInfo, Intent&gt; resolveSecondaryHomeActivity(int userId, int displayId) &#123;445 if (displayId &#x3D;&#x3D; DEFAULT_DISPLAY) &#123;446 throw new IllegalArgumentException(447 &quot;resolveSecondaryHomeActivity: Should not be DEFAULT_DISPLAY&quot;);448 &#125;449 &#x2F;&#x2F; Resolve activities in the same package as currently selected primary home activity.450 Intent homeIntent &#x3D; mService.getHomeIntent();451 ActivityInfo aInfo &#x3D; resolveHomeActivity(userId, homeIntent);452 if (aInfo !&#x3D; null) &#123;453 if (ResolverActivity.class.getName().equals(aInfo.name)) &#123;454 &#x2F;&#x2F; Always fallback to secondary home component if default home is not set.455 aInfo &#x3D; null;456 &#125; else &#123;457 &#x2F;&#x2F; Look for secondary home activities in the currently selected default home458 &#x2F;&#x2F; package.459 homeIntent &#x3D; mService.getSecondaryHomeIntent(aInfo.applicationInfo.packageName);460 final List&lt;ResolveInfo&gt; resolutions &#x3D; resolveActivities(userId, homeIntent);461 final int size &#x3D; resolutions.size();462 final String targetName &#x3D; aInfo.name;463 aInfo &#x3D; null;464 for (int i &#x3D; 0; i &lt; size; i++) &#123;465 ResolveInfo resolveInfo &#x3D; resolutions.get(i);466 &#x2F;&#x2F; We need to traverse all resolutions to check if the currently selected467 &#x2F;&#x2F; default home activity is present.468 if (resolveInfo.activityInfo.name.equals(targetName)) &#123;469 aInfo &#x3D; resolveInfo.activityInfo;470 break;471 &#125;472 &#125;473 if (aInfo &#x3D;&#x3D; null &amp;&amp; size &gt; 0) &#123;474 &#x2F;&#x2F; First one is the best.475 aInfo &#x3D; resolutions.get(0).activityInfo;476 &#125;477 &#125;478 &#125;479480 if (aInfo !&#x3D; null) &#123;481 if (!canStartHomeOnDisplay(aInfo, displayId, false &#x2F;* allowInstrumenting *&#x2F;)) &#123;482 aInfo &#x3D; null;483 &#125;484 &#125;485486 &#x2F;&#x2F; Fallback to secondary home component.487 if (aInfo &#x3D;&#x3D; null) &#123;488 homeIntent &#x3D; mService.getSecondaryHomeIntent(null);489 aInfo &#x3D; resolveHomeActivity(userId, homeIntent);490 &#125;491 return Pair.create(aInfo, homeIntent);492 &#125; ​ 第二关的核心方法就是mService.getSecondaryHomeIntent，其中从上面的代码中看到，有两种情况，传入了两个不同的参数，第一个是已经启动的Home所在的包名，第二个是null. 1234567891011121314151617185869 Intent getSecondaryHomeIntent(String preferredPackage) &#123;5870 final Intent intent &#x3D; new Intent(mTopAction, mTopData !&#x3D; null ? Uri.parse(mTopData) : null);5871 final boolean useSystemProvidedLauncher &#x3D; mContext.getResources().getBoolean(5872 com.android.internal.R.bool.config_useSystemProvidedLauncherForSecondary);5873 if (preferredPackage &#x3D;&#x3D; null || useSystemProvidedLauncher) &#123;5874 &#x2F;&#x2F; Using the component stored in config if no package name or forced.5875 final String secondaryHomeComponent &#x3D; mContext.getResources().getString(5876 com.android.internal.R.string.config_secondaryHomeComponent);5877 intent.setComponent(ComponentName.unflattenFromString(secondaryHomeComponent));5878 &#125; else &#123;5879 intent.setPackage(preferredPackage);5880 &#125;5881 intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);5882 if (mFactoryTest !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;5883 intent.addCategory(Intent.CATEGORY_SECONDARY_HOME);5884 &#125;5885 return intent;5886 &#125; ​ 如果将config_useSystemProvidedLauncherForSecondary配置为true，那么就会使用config_secondaryHomeComponent所配置的Home，这种做法可用于指定特定的SecondaryHome。但config_useSystemProvidedLauncherForSecondary默认是false，也就是会根据已启动的Home所在的包中的CATEGORY_SECONDARY_HOME定义的Home，因为一些Launcher会有支持上SecondaryHome，当launcher中找不到SecondaryHome，才会去使用默认的SecondaryHome。第二种情况是主显的launcher没有启动时走的流程，也就是使用默认的SecondaryHome。 ​ 至此就完成了查找SecondaryHome的任务。 canStartHomeOnDisplay1234567891011121314151617181920212223242526272829303132333435582 boolean canStartHomeOnDisplay(ActivityInfo homeInfo, int displayId,583 boolean allowInstrumenting) &#123;584 if (mService.mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL585 &amp;&amp; mService.mTopAction == null) &#123;586 // We are running in factory test mode, but unable to find the factory test app, so587 // just sit around displaying the error message and don't try to start anything.588 return false;589 &#125;590591 final WindowProcessController app =592 mService.getProcessController(homeInfo.processName, homeInfo.applicationInfo.uid);593 if (!allowInstrumenting &amp;&amp; app != null &amp;&amp; app.isInstrumenting()) &#123;594 // Don't do this if the home app is currently being instrumented.595 return false;596 &#125;597598 if (displayId == DEFAULT_DISPLAY || (displayId != INVALID_DISPLAY599 &amp;&amp; displayId == mService.mVr2dDisplayId)) &#123;600 // No restrictions to default display or vr 2d display.601 return true;602 &#125;603604 if (!shouldPlaceSecondaryHomeOnDisplay(displayId)) &#123;605 return false;606 &#125;607608 final boolean supportMultipleInstance = homeInfo.launchMode != LAUNCH_SINGLE_TASK609 &amp;&amp; homeInfo.launchMode != LAUNCH_SINGLE_INSTANCE;610 if (!supportMultipleInstance) &#123;611 // Can't launch home on secondary displays if it requested to be single instance.612 return false;613 &#125;614615 return true;616 &#125; ​ canStartHomeOnDisplay的核心是shouldPlaceSecondaryHomeOnDisplay，而这个就是我们第一关的内容，因此毫无疑问，这关轻松闯过。 startHomeActivity​ 闯完三关后，就到了真正的启动，从前面的参数可以知道，HomeActivity的启动必定加上FLAG_ACTIVITY_NEW_TASK这个flag参数，表示HomeActivity是要在新的Task中启动的，这很容易理解。 ​ 我们继续看startHomeActivity是如何将Home启动到副屏上的： 123456789101112131415161718192021222324252627171 void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason, int displayId) &#123;172 final ActivityOptions options = ActivityOptions.makeBasic();173 options.setLaunchWindowingMode(WINDOWING_MODE_FULLSCREEN);174 if (!ActivityRecord.isResolverActivity(aInfo.name)) &#123;175 // The resolver activity shouldn't be put in home stack because when the foreground is176 // standard type activity, the resolver activity should be put on the top of current177 // foreground instead of bring home stack to front.178 options.setLaunchActivityType(ACTIVITY_TYPE_HOME);179 &#125;180 options.setLaunchDisplayId(displayId);181 mLastHomeActivityStartResult = obtainStarter(intent, \"startHomeActivity: \" + reason)182 .setOutActivity(tmpOutRecord)183 .setCallingUid(0)184 .setActivityInfo(aInfo)185 .setActivityOptions(options.toBundle())186 .execute();187 mLastHomeActivityStartRecord = tmpOutRecord[0];188 final ActivityDisplay display =189 mService.mRootActivityContainer.getActivityDisplay(displayId);190 final ActivityStack homeStack = display != null ? display.getHomeStack() : null;191 if (homeStack != null &amp;&amp; homeStack.mInResumeTopActivity) &#123;192 // If we are in resume section already, home activity will be initialized, but not193 // resumed (to avoid recursive resume) and will stay that way until something pokes it194 // again. We need to schedule another resume.195 mSupervisor.scheduleResumeTopActivities();196 &#125;197 &#125; ​ 显示到副屏的关键是–options.setLaunchDisplayId(displayId)，ActivityOptions是Activity的启动参数，setLaunchDisplayId就是设置了Activity在哪个display上进行启动。而这个详细的过程可以看am命令在副屏上启动Activity的详细分析。 总结​ 总的来说，AndroidQ已经支持得十分好，如果需要打开双Home启动，那么可以通过以下步骤去进行。 ​ 1.最好将设备设置为非LowRam设备。 ​ 2.打开多窗口模式，如果是非LowRam设备，默认也是打开的。 ​ 3.准备一个SecondaryHome应用，Android提供的Launcher3其实已经支持，但也可以自行配置。 ​ 4.通过settings put global force_desktop_mode_on_external_displays 1去打开双Home。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"AMS","slug":"AMS","permalink":"https://chongyuzhao.github.io/tags/AMS/"}]},{"title":"Android多屏幕专题--开篇","date":"2020-03-21T13:58:57.000Z","path":"2020/03/21/Android多屏幕专题-开篇/","text":"Android多屏幕​ Android从4.4开始其实就已经有了(不确定最初是哪个版本)，在Android6.0的时候就有Presentation作为异显开发，而到AndroidQ，就已经发现有双Home(两个launcher，可以在两个显示屏上打开应用)。而我对这一块一直都比较感兴趣，而且涉及了Android frameworks很多的内容，诸如AMS、WMS、DisplayManagerService、SurfaceFlinger和Input等等。随着嵌入式芯片的性能越来越强，多屏操作也就不再吃力，Android也越来越接近像windows那样强大的界面操作能力。 分析步骤​ 由于多屏幕异显部分设计的子系统繁多，我们将逐一分块进行分析，大概步骤如下: ​ 1.从双home场景进行分析，了解两个Home是如何启动与显示。 ​ 2.了解Presentation的原理，分析其是如何显示到其他的屏幕上。 ​ 3.了解AMS是如何管理多个屏幕的，如何组织或者启动一个Activity到另一个屏幕上。 ​ 4.了解WMS是如何管理多个屏幕的windows。 ​ 5.了解SurfaceFlinger是如何合成和显示不同屏幕的视图。 ​ 6.了解InputFlinger的不同屏幕的Viewport更新机制。 ​ ……","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"AMS","slug":"AMS","permalink":"https://chongyuzhao.github.io/tags/AMS/"},{"name":"WMS","slug":"WMS","permalink":"https://chongyuzhao.github.io/tags/WMS/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android Input子系统专题-输入路由","date":"2020-03-20T13:19:34.000Z","path":"2020/03/20/input/Android-Input子系统专题-输入路由/","text":"Android Input输入路由​ 路由在我们生活中基本都有接触，而我们这里说的输入路由主要是用在多屏幕多触摸输入设备中，设计者可以为对应的屏幕指定对应的输入设备，而这功能就是所谓的输入路由。 ​ 从InputFlinger的学习中我们知道，在InputFlinger中没有屏幕(Screen)的概念，而我们的输入事件是通过查找对应的Viewport(视口)来发送到对应的窗口，而窗口在指定的屏幕上，也即是对应的输入事件发送到指定的屏幕中。在底层我们是不知道哪个触摸设备对应哪个屏幕的，例如当有两个HDMI设备时，那么我们哪个触摸设备对应哪个显示器呢，这是很不好去判断的，一般查找Viewport有以下4种情况： ​ 1.如果有在设备路由表中定义，则根据路由表的display id进行查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 2.如果idc配置文件中有定义touch.displayId字段，则根据该字段进行匹配查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 3.根据设备类型进行查找，如果设备属于内置类型输入设备，则会匹配到内置的display，而如果属于外置输入设备，如usb触摸屏等，则会去匹配外置的display。 ​ 4.在第3点的以外情况，即如果是外置输入设备，但没有匹配到外置的display，则会匹配默认的内置display。 ​ 以上4种情况可直接参考TouchInputMapper::findViewport的具体实现。 ​ 输入路由就是针对第一种情况。具体的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940413458 std::optional&lt;DisplayViewport&gt; TouchInputMapper::findViewport() &#123;3459 if (mParameters.hasAssociatedDisplay) &#123;3460 const std::optional&lt;uint8_t&gt; displayPort = mDevice-&gt;getAssociatedDisplayPort();3461 if (displayPort) &#123;3462 // Find the viewport that contains the same port3463 std::optional&lt;DisplayViewport&gt; v = mConfig.getDisplayViewportByPort(*displayPort);3464 if (!v) &#123;3465 ALOGW(\"Input device %s should be associated with display on port %\" PRIu8 \", \"3466 \"but the corresponding viewport is not found.\",3467 getDeviceName().c_str(), *displayPort);3468 &#125;3469 return v;3470 &#125; ……3501 &#125; 262 inline std::optional&lt;uint8_t&gt; getAssociatedDisplayPort() const &#123; 263 return mAssociatedDisplayPort; 264 &#125; 1067 void InputDevice::configure(nsecs_t when, const InputReaderConfiguration* config, uint32_t changes) &#123;1068 mSources = 0;1069 ……11001101 if (!changes || (changes &amp; InputReaderConfiguration::CHANGE_DISPLAY_INFO)) &#123;1102 // In most situations, no port will be specified.1103 mAssociatedDisplayPort = std::nullopt;1104 // Find the display port that corresponds to the current input port.1105 const std::string&amp; inputPort = mIdentifier.location;1106 if (!inputPort.empty()) &#123;1107 const std::unordered_map&lt;std::string, uint8_t&gt;&amp; ports = config-&gt;portAssociations;1108 const auto&amp; displayPort = ports.find(inputPort);1109 if (displayPort != ports.end()) &#123;1110 mAssociatedDisplayPort = std::make_optional(displayPort-&gt;second);1111 &#125;1112 &#125;1113 &#125;1114 ……1120 &#125; ​ 从上述的代码可以看到，输入路由就是通过InputDevice的location来从portAssociations表中去查找display。portAssociations的值我们可以逆推找到，也可以从官网的介绍文档中得知 – /vendor/etc/input-port-associations.xml，值的获取如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501905 private static String[] getInputPortAssociations() &#123;1906 File baseDir = Environment.getVendorDirectory();1907 File confFile = new File(baseDir, PORT_ASSOCIATIONS_PATH);19081909 try &#123;1910 InputStream stream = new FileInputStream(confFile);1911 List&lt;Pair&lt;String, String&gt;&gt; associations =1912 ConfigurationProcessor.processInputPortAssociations(stream);1913 List&lt;String&gt; associationList = flatten(associations);1914 return associationList.toArray(new String[0]);1915 &#125; catch (FileNotFoundException e) &#123;1916 // Most of the time, file will not exist, which is expected.1917 &#125; catch (Exception e) &#123;1918 Slog.e(TAG, \"Could not parse '\" + confFile.getAbsolutePath() + \"'\", e);1919 &#125;1920 return new String[0];1921 &#125; 88 @VisibleForTesting 89 static List&lt;Pair&lt;String, String&gt;&gt; processInputPortAssociations(InputStream xml) 90 throws Exception &#123; 91 List&lt;Pair&lt;String, String&gt;&gt; associations = new ArrayList&lt;&gt;(); 92 try (InputStreamReader confReader = new InputStreamReader(xml)) &#123; 93 XmlPullParser parser = Xml.newPullParser(); 94 parser.setInput(confReader); 95 XmlUtils.beginDocument(parser, \"ports\"); 96 97 while (true) &#123; 98 XmlUtils.nextElement(parser); 99 String entryName = parser.getName();100 if (!\"port\".equals(entryName)) &#123;101 break;102 &#125;103 String inputPort = parser.getAttributeValue(null, \"input\");104 String displayPort = parser.getAttributeValue(null, \"display\");105 if (TextUtils.isEmpty(inputPort) || TextUtils.isEmpty(displayPort)) &#123;106 // This is likely an error by an OEM during device configuration107 Slog.wtf(TAG, \"Ignoring incomplete entry\");108 continue;109 &#125;110 try &#123;111 Integer.parseUnsignedInt(displayPort);112 &#125; catch (NumberFormatException e) &#123;113 Slog.wtf(TAG, \"Display port should be an integer\");114 continue;115 &#125;116 associations.add(new Pair&lt;&gt;(inputPort, displayPort));117 &#125;118 &#125;119 return associations;120 &#125; ​ 从代码上看，输入路由的配置文件input-port-associations.xml的格式如下： 1234&lt;ports&gt; &lt;port display=\"0\" input=\"usb-xhci-hcd.0.auto-1.1/input0\" /&gt; &lt;port display=\"1\" input=\"usb-xhci-hcd.0.auto-1.2/input0\" /&gt;&lt;/ports&gt; ​ 顶层以为tag，子节点为一组display-input配置。display属性是一个整形值，对应了displayId，input属性是输入设备的描述。回顾InputDevice::configure方法的内容，input的字段对应了InputDevice的location字段。displayId我们很好理解，就是显示设备在Display系统中的idz中，我们可以通过dumpsys display来获取，而这个location值也可以通过dumpsys input来获取设备对应的值。display的值是一个整数，范围是[0,255]。 ​ 我们再看以下location这个值是从哪里来的： 12345678910111189 status_t EventHub::openDeviceLocked(const char* devicePath) &#123; ……1240 // Get device physical location.1241 if(ioctl(fd, EVIOCGPHYS(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;1242 //fprintf(stderr, \"could not get location for %s, %s\\n\", devicePath, strerror(errno));1243 &#125; else &#123;1244 buffer[sizeof(buffer) - 1] = '\\0';1245 identifier.location = buffer;1246 &#125; ……1477 &#125; ​ location就是input设备驱动中的phys。 总结​ 输入路由其实就是简单的由一个xml文件对输入设备(触摸设备)和显示设备之间进行绑定。我觉得可以由以下的用途： ​ 1.多个外置的输入设备和显示设备，需要指定对应的输入和显示设备关系，可以使用输入路由控制。 ​ 2.一个内置一个外置的输入设备和显示设备。当两个显示器进行同显时(此时只有一个viewport)，那么两个输入设备都可以控制主显，而我们又不希望如此时，可以通过输入路由指定外置输入设备控制外置显示设备(即当只有异显时才生效)。 ​ 3.将某个输入设备的display设成一个不存在的displayId，那么就可以禁止掉输入设备的事件(有点多此一举，因为可通过excluded-input-devices.xml让对应的设备不进行注册，但这种做法可以禁止掉一类型的输入设备事件上报，也不失为一种方式)。 ​ 如果大家还有其他想到的用途，欢迎交流~ ，","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android Input子系统专题-InputFlinger(一)","date":"2020-03-15T13:39:40.000Z","path":"2020/03/15/input/Android-Input子系统专题-InputFlinger(一)/","text":"InputFlinger的启动​ InputFlinger的源码在frameworks/native/services/inputflinger目录下，其是作为一个lib而存在，因此启动的代码也并不在这里。InputFlinger实际上是通过IMS的JNI启动起来的，在InputFlinger的源码目录下，是没有InputFlinger这么一个东西，host目录下的内容实际上并没有使用到。虽然没有InputFlinger这个类，但既然叫InputFlinger，那当然与这个名字有关系，我们可以看到，有一个BnInputFlinger的接口，而InputManager继承了这个接口，说明InputManager就是InputFlinger的service端： 181 class InputManager : public InputManagerInterface, public BnInputFlinger &#123; ​ 那么这个InputManager是被谁创建启动的呢？一般这种情况不是通过rc文件启动的，就很高概率是android的Java服务通过JNI去创建和启动服务了： 123456789101112131415161718192021222324252627282930313233343536// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp 333 NativeInputManager::NativeInputManager(jobject contextObj, 334 jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) : 335 mLooper(looper), mInteractive(true) &#123; 336 JNIEnv* env = jniEnv(); 337 338 mServiceObj = env-&gt;NewGlobalRef(serviceObj); 339 340 &#123; 341 AutoMutex _l(mLock); 342 mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE; 343 mLocked.pointerSpeed = 0; 344 mLocked.pointerGesturesEnabled = true; 345 mLocked.showTouches = false; 346 mLocked.pointerCapture = false; 347 mLocked.pointerDisplayId = ADISPLAY_ID_DEFAULT; 348 &#125; 349 mInteractive = true; 350 351 mInputManager = new InputManager(this, this); 352 defaultServiceManager()-&gt;addService(String16(\"inputflinger\"), 353 mInputManager, false); 354 &#125;1317 static jlong nativeInit(JNIEnv* env, jclass /* clazz */,1318 jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;1319 sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);1320 if (messageQueue == nullptr) &#123;1321 jniThrowRuntimeException(env, \"MessageQueue is not initialized.\");1322 return 0;1323 &#125;13241325 NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,1326 messageQueue-&gt;getLooper());1327 im-&gt;incStrong(0);1328 return reinterpret_cast&lt;jlong&gt;(im);1329 &#125; ​ NativeInputManager在创建了InputManager后就将其注册到servicemanager中，并将其命名为Inputflinger。 ​ 从文件名我们就可以得知这部分属于InputManagerService的JNI部分，也就是说InputManagerService在启动的过程中，就会启动InputFlinger. InputFlinger的核心​ 看完InputFlinger是由谁启动的之后，我们再会过头来看看InputFlinger在启动的过程中干了哪些事，看看哪些是我们后续学习的重点。 1234567833 InputManager::InputManager(34 const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,35 const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;36 mDispatcher = new InputDispatcher(dispatcherPolicy);37 mClassifier = new InputClassifier(mDispatcher);38 mReader = createInputReader(readerPolicy, mClassifier);39 initialize();40 &#125; ​ InputManager在构造的过程中，创建了三个重要的对象，分别是mDispatcher(InputDispatcher)、mClassifier(InputClassifier)和mReader(InputReader)。这三个东西中InputDispatcher和InputReader在之前的工作中接触得最多，而InputClassifer倒是很少接触，后续会研究以下这东西是干嘛的。 123446 void InputManager::initialize() &#123;47 mReaderThread = new InputReaderThread(mReader);48 mDispatcherThread = new InputDispatcherThread(mDispatcher);49 &#125; ​ 之后就为mReader和mDispatcher分别创建一个线程去分工合作，由此可以看到，InputFlinger至少是有两个子线程在跑的。创建子线程之后当然就是去执行它们，这我们就不在这里展开了。 小结​ InputFlinger的核心实际上就只有两个半：InputDispatcher和InputReader，还有一个未知的InputClassifier，我们后续的工作主要就是去分析这两个核心干了哪些大事。 ​ 下图是InputFlinger的类图：","tags":[{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"},{"name":"AndroidQ","slug":"AndroidQ","permalink":"https://chongyuzhao.github.io/tags/AndroidQ/"}]},{"title":"Android input子系统专题--开篇","date":"2020-03-15T05:16:00.000Z","path":"2020/03/15/input/Android-input子系统专题-开篇/","text":"Android Input的分层​ Android的input子系统大概是在2019年的3、4月份开始接触的，主要是因为负责Input部分的同事离职了，我就当仁不让地接上了这个话。Android是一个交互式的操作系统，显示与输入都是一个重要的组成部分。Android支持多种多样的输入设备，如触摸、游戏手柄、按键、鼠标、键盘等等。 ​ 基于Android与Linux的关系，Android的input子系统也是可分成三层：设备驱动层 - inputflinger层 - 应用处理层。设备驱动层与inputflinger层之间是通过Linux的设备驱动节点进行连接，inputflinger与应用层之前是通过InputChannel来进行连接。 123graph BTDriver[设备驱动] &#x3D;&#x3D; VFS &#x3D;&#x3D;&gt; InputFlinger[InputFlinger]InputFlinger[InputFlinger] &#x3D;&#x3D; InputChannel &#x3D;&#x3D;&gt; APP[应用] ​ 设备驱动层决定了系统支持什么类型的设备，没有对应的驱动配置就成了巧妇难为无米之炊，如果没有触摸驱动，那么如何来触摸，USB没有配置好，那么USB鼠标键盘如何使用。设备驱动层是基础，后面在对这部分分析的时候，我们不针对具体的设备驱动，而是对input事件的从驱动层到用户节点的过程。 ​ inputflinger是Android的快递员，接收底层驱动投递的输入事件，然后经过封装分发给对应的客户。这一块也是目前接触最多的部分，后面将重点分析这一块。 ​ 应用层则是Android真正处理事件的地方，输入事件的存在感就是由处理它的人体验的，这一部分很多时候已经被各种view给处理，剩余的则由应用去处理，平时我们所override的onKeyDown/onTouchEvent等等回调，就是我们研究的对象。 分析步骤1. InputFlinger的工作原理 1. 设备的配置文件 2. KeyEvent的处理过程 3. TouchEvent的处理过程 2. InputChannel的创建 3. InputFlinger分发事件到应用的过程 4. Driver的事件上报过程。总结​ 学无止境，每次重新看代码都会有不同的感悟，特别是Android版本的更新频繁，虽大体的框架不会变动太大，但也是有无穷的东西需要学习和总结。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"input","slug":"input","permalink":"https://chongyuzhao.github.io/tags/input/"}]}]