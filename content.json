[{"title":"Android Input子系统专题-输入路由","date":"2020-03-20T13:19:34.000Z","path":"2020/03/20/Android-Input子系统专题-输入路由/","text":"Android Input输入路由​ 路由在我们生活中基本都有接触，而我们这里说的输入路由主要是用在多屏幕多触摸输入设备中，设计者可以为对应的屏幕指定对应的输入设备，而这功能就是所谓的输入路由。 ​ 从InputFlinger的学习中我们知道，在InputFlinger中没有屏幕(Screen)的概念，而我们的输入事件是通过查找对应的Viewport(视口)来发送到对应的窗口，而窗口在指定的屏幕上，也即是对应的输入事件发送到指定的屏幕中。在底层我们是不知道哪个触摸设备对应哪个屏幕的，例如当有两个HDMI设备时，那么我们哪个触摸设备对应哪个显示器呢，这是很不好去判断的，一般查找Viewport有以下4种情况： ​ 1.如果有在设备路由表中定义，则根据路由表的display id进行查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 2.如果idc配置文件中有定义touch.displayId字段，则根据该字段进行匹配查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 3.根据设备类型进行查找，如果设备属于内置类型输入设备，则会匹配到内置的display，而如果属于外置输入设备，如usb触摸屏等，则会去匹配外置的display。 ​ 4.在第3点的以外情况，即如果是外置输入设备，但没有匹配到外置的display，则会匹配默认的内置display。 ​ 以上4种情况可直接参考TouchInputMapper::findViewport的具体实现。 ​ 输入路由就是针对第一种情况。具体的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940413458 std::optional&lt;DisplayViewport&gt; TouchInputMapper::findViewport() &#123;3459 if (mParameters.hasAssociatedDisplay) &#123;3460 const std::optional&lt;uint8_t&gt; displayPort = mDevice-&gt;getAssociatedDisplayPort();3461 if (displayPort) &#123;3462 // Find the viewport that contains the same port3463 std::optional&lt;DisplayViewport&gt; v = mConfig.getDisplayViewportByPort(*displayPort);3464 if (!v) &#123;3465 ALOGW(\"Input device %s should be associated with display on port %\" PRIu8 \", \"3466 \"but the corresponding viewport is not found.\",3467 getDeviceName().c_str(), *displayPort);3468 &#125;3469 return v;3470 &#125; ……3501 &#125; 262 inline std::optional&lt;uint8_t&gt; getAssociatedDisplayPort() const &#123; 263 return mAssociatedDisplayPort; 264 &#125; 1067 void InputDevice::configure(nsecs_t when, const InputReaderConfiguration* config, uint32_t changes) &#123;1068 mSources = 0;1069 ……11001101 if (!changes || (changes &amp; InputReaderConfiguration::CHANGE_DISPLAY_INFO)) &#123;1102 // In most situations, no port will be specified.1103 mAssociatedDisplayPort = std::nullopt;1104 // Find the display port that corresponds to the current input port.1105 const std::string&amp; inputPort = mIdentifier.location;1106 if (!inputPort.empty()) &#123;1107 const std::unordered_map&lt;std::string, uint8_t&gt;&amp; ports = config-&gt;portAssociations;1108 const auto&amp; displayPort = ports.find(inputPort);1109 if (displayPort != ports.end()) &#123;1110 mAssociatedDisplayPort = std::make_optional(displayPort-&gt;second);1111 &#125;1112 &#125;1113 &#125;1114 ……1120 &#125; ​ 从上述的代码可以看到，输入路由就是通过InputDevice的location来从portAssociations表中去查找display。portAssociations的值我们可以逆推找到，也可以从官网的介绍文档中得知 – /vendor/etc/input-port-associations.xml，值的获取如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501905 private static String[] getInputPortAssociations() &#123;1906 File baseDir = Environment.getVendorDirectory();1907 File confFile = new File(baseDir, PORT_ASSOCIATIONS_PATH);19081909 try &#123;1910 InputStream stream = new FileInputStream(confFile);1911 List&lt;Pair&lt;String, String&gt;&gt; associations =1912 ConfigurationProcessor.processInputPortAssociations(stream);1913 List&lt;String&gt; associationList = flatten(associations);1914 return associationList.toArray(new String[0]);1915 &#125; catch (FileNotFoundException e) &#123;1916 // Most of the time, file will not exist, which is expected.1917 &#125; catch (Exception e) &#123;1918 Slog.e(TAG, \"Could not parse '\" + confFile.getAbsolutePath() + \"'\", e);1919 &#125;1920 return new String[0];1921 &#125; 88 @VisibleForTesting 89 static List&lt;Pair&lt;String, String&gt;&gt; processInputPortAssociations(InputStream xml) 90 throws Exception &#123; 91 List&lt;Pair&lt;String, String&gt;&gt; associations = new ArrayList&lt;&gt;(); 92 try (InputStreamReader confReader = new InputStreamReader(xml)) &#123; 93 XmlPullParser parser = Xml.newPullParser(); 94 parser.setInput(confReader); 95 XmlUtils.beginDocument(parser, \"ports\"); 96 97 while (true) &#123; 98 XmlUtils.nextElement(parser); 99 String entryName = parser.getName();100 if (!\"port\".equals(entryName)) &#123;101 break;102 &#125;103 String inputPort = parser.getAttributeValue(null, \"input\");104 String displayPort = parser.getAttributeValue(null, \"display\");105 if (TextUtils.isEmpty(inputPort) || TextUtils.isEmpty(displayPort)) &#123;106 // This is likely an error by an OEM during device configuration107 Slog.wtf(TAG, \"Ignoring incomplete entry\");108 continue;109 &#125;110 try &#123;111 Integer.parseUnsignedInt(displayPort);112 &#125; catch (NumberFormatException e) &#123;113 Slog.wtf(TAG, \"Display port should be an integer\");114 continue;115 &#125;116 associations.add(new Pair&lt;&gt;(inputPort, displayPort));117 &#125;118 &#125;119 return associations;120 &#125; ​ 从代码上看，输入路由的配置文件input-port-associations.xml的格式如下： 1234&lt;ports&gt; &lt;port display=\"0\" input=\"usb-xhci-hcd.0.auto-1.1/input0\" /&gt; &lt;port display=\"1\" input=\"usb-xhci-hcd.0.auto-1.2/input0\" /&gt;&lt;/ports&gt; ​ 顶层以为tag，子节点为一组display-input配置。display属性是一个整形值，对应了displayId，input属性是输入设备的描述。回顾InputDevice::configure方法的内容，input的字段对应了InputDevice的location字段。displayId我们很好理解，就是显示设备在Display系统中的idz中，我们可以通过dumpsys display来获取，而这个location值也可以通过dumpsys input来获取设备对应的值。 ​ 我们再看以下location这个值是从哪里来的： 12345678910111189 status_t EventHub::openDeviceLocked(const char* devicePath) &#123; ……1240 // Get device physical location.1241 if(ioctl(fd, EVIOCGPHYS(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;1242 //fprintf(stderr, \"could not get location for %s, %s\\n\", devicePath, strerror(errno));1243 &#125; else &#123;1244 buffer[sizeof(buffer) - 1] = '\\0';1245 identifier.location = buffer;1246 &#125; ……1477 &#125; ​ location就是input设备驱动中的phys。 总结​ 输入路由其实就是简单的由一个xml文件对输入设备(触摸设备)和显示设备之间进行绑定。我觉得可以由以下的用途： ​ 1.多个外置的输入设备和显示设备，需要指定对应的输入和显示设备关系，可以使用输入路由控制。 ​ 2.一个内置一个外置的输入设备和显示设备。当两个显示器进行同显时(此时只有一个viewport)，那么两个输入设备都可以控制主显，而我们又不希望如此时，可以通过输入路由指定外置输入设备控制外置显示设备(即当只有异显时才生效)。 ​ 3.将某个输入设备的display设成一个不存在的displayId，那么就可以禁止掉输入设备的事件(有点多此一举，因为可通过excluded-input-devices.xml让对应的设备不进行注册，但这种做法可以禁止掉一类型的输入设备事件上报，也不失为一种方式)。 ​ 如果大家还有其他想到的用途，欢迎交流~ ，","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android Input子系统专题-InputFlinger(一)","date":"2020-03-15T13:39:40.000Z","path":"2020/03/15/Android-Input子系统专题-InputFlinger/","text":"InputFlinger的启动​ InputFlinger在Android(至少在AndroiP及以后的版本)中作为一个服务而存在，如果有学习过Android的服务启动，那么对InputFlinger的启动也将会十分熟悉，在本文将简单地介绍一下它的启动。 ​ InputFlinger的源码在frameworks/native/services/inputflinger目录下，在该目录下有一个host目录，这里面就是InputFlinger的服务程序，而与host目录同级下的源码则是InputFlinger的核心代码–libinputflinger。 ​ 在host目录下有一个inputflinger.rc文件： 12345service inputflinger &#x2F;system&#x2F;bin&#x2F;inputflinger class main user system group input wakelock# onrestart restart zygote ​ InputFlinger属于main组别的服务，group是input和wakelock，由于需要读取/dev/input/*下的设备节点，因此需要input group，而且部分设备还具备唤醒系统，因此还有wakelock的group。 ​ 最后一个onrestart restart zygote，说明之前的版本inputflinger如果挂掉，那么Android将会重启，但AndroidP后就不需要这么做了，因为当inputflinger挂掉后，init会将它重启。而其他地方估计是没有其他的服务去引用它，其相对独立。这个可在后续研究一下。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android input子系统专题--开篇","date":"2020-03-15T05:16:00.000Z","path":"2020/03/15/Android-input子系统专题-开篇/","text":"Android Input的分层​ Android的input子系统大概是在2019年的3、4月份开始接触的，主要是因为负责Input部分的同事离职了，我就当仁不让地接上了这个话。Android是一个交互式的操作系统，显示与输入都是一个重要的组成部分。Android支持多种多样的输入设备，如触摸、游戏手柄、按键、鼠标、键盘等等。 ​ 基于Android与Linux的关系，Android的input子系统也是可分成三层：设备驱动层 - inputflinger层 - 应用处理层。设备驱动层与inputflinger层之间是通过Linux的设备驱动节点进行连接，inputflinger与应用层之前是通过InputChannel来进行连接。 123graph BTDriver[设备驱动] &#x3D;&#x3D; VFS &#x3D;&#x3D;&gt; InputFlinger[InputFlinger]InputFlinger[InputFlinger] &#x3D;&#x3D; InputChannel &#x3D;&#x3D;&gt; APP[应用] ​ 设备驱动层决定了系统支持什么类型的设备，没有对应的驱动配置就成了巧妇难为无米之炊，如果没有触摸驱动，那么如何来触摸，USB没有配置好，那么USB鼠标键盘如何使用。设备驱动层是基础，后面在对这部分分析的时候，我们不针对具体的设备驱动，而是对input事件的从驱动层到用户节点的过程。 ​ inputflinger是Android的快递员，接收底层驱动投递的输入事件，然后经过封装分发给对应的客户。这一块也是目前接触最多的部分，后面将重点分析这一块。 ​ 应用层则是Android真正处理事件的地方，输入事件的存在感就是由处理它的人体验的，这一部分很多时候已经被各种view给处理，剩余的则由应用去处理，平时我们所override的onKeyDown/onTouchEvent等等回调，就是我们研究的对象。 分析步骤1. InputFlinger的工作原理 1. 设备的配置文件 2. KeyEvent的处理过程 3. TouchEvent的处理过程 2. InputChannel的创建 3. InputFlinger分发事件到应用的过程 4. Driver的事件上报过程。总结​ 学无止境，每次重新看代码都会有不同的感悟，特别是Android版本的更新频繁，虽大体的框架不会变动太大，但也是有无穷的东西需要学习和总结。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"input","slug":"input","permalink":"https://chongyuzhao.github.io/tags/input/"}]}]