[{"title":"Android-Input子系统专题-InputFlinger(二)之InputReader","date":"2020-03-26T13:25:56.000Z","path":"2020/03/26/input/Android-Input子系统专题-InputFlinger(二)之InputReader/","text":"​ 从InputFlinger的启动篇我们可以知道，InputReader是InputFlinger的核心之一，我们这一篇就围绕这InputReader进行分析研究。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android多屏幕专题--双Home的启动","date":"2020-03-22T02:54:36.000Z","path":"2020/03/22/Android多屏幕专题-双Home的启动/","text":"Android多屏幕专题 – 双Home的启动​ 在一个偶然的机会下，发现AndroidQ是支持两个Launcher的，在两个显示设备的情况下，可以分别启动两个Launcher，在这两个Launcher中都可以操作，如打开应用，虚拟导航栏等，也就是说，使用这种模式，是可以同时打开两个应用分别操作。 ​ 启动双Home的方式，首先是这个Android系统不能是低内存设备(low ram device)，其次可通过settings put global force_desktop_mode_on_external_displays 1，重启后两个显示器上就有不同的Home了。 ​ 下面我们就来看看这个settings字段是如何控制双Home的启动。前面的代码追溯我们就不一一展开，直接从SystemServer启动完成后就会调用AMS的systemReady方法，而在AMS的systemReady中就会去启动我们的Launcher: 123456789101112131415161718192021 8960 public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) &#123; …… 9076 mAtmInternal.startHomeOnAllDisplays(currentUserId, \"systemReady\"); …… 9136 &#125;6691 @Override6692 public boolean startHomeOnAllDisplays(int userId, String reason) &#123;6693 synchronized (mGlobalLock) &#123;6694 return mRootActivityContainer.startHomeOnAllDisplays(userId, reason);6695 &#125;6696 &#125; 332 boolean startHomeOnAllDisplays(int userId, String reason) &#123; 333 boolean homeStarted = false; 334 for (int i = mActivityDisplays.size() - 1; i &gt;= 0; i--) &#123; 335 final int displayId = mActivityDisplays.get(i).mDisplayId; 336 homeStarted |= startHomeOnDisplay(userId, reason, displayId); 337 &#125; 338 return homeStarted; 339 &#125; startHomeOnDisplay​ mActivityDisplays中记录了启动过程中所注册进来的display，在AMS中，使用ActivityDisplay来描述显示屏，这里的startHomeOnAllDisplays就是去为所有的显示屏去启动一个Home，当然啦，并不是一定会为每个屏幕都启动一个Home. 1234567891011121314151617181920212223242526272829303132333435363738394041424344350 boolean startHomeOnDisplay(int userId, String reason, int displayId) &#123;351 return startHomeOnDisplay(userId, reason, displayId, false /* allowInstrumenting */,352 false /* fromHomeKey */);353 &#125;366 boolean startHomeOnDisplay(int userId, String reason, int displayId, boolean allowInstrumenting,367 boolean fromHomeKey) &#123;368 // Fallback to top focused display if the displayId is invalid.369 if (displayId == INVALID_DISPLAY) &#123;370 displayId = getTopDisplayFocusedStack().mDisplayId;371 &#125;372373 Intent homeIntent = null;374 ActivityInfo aInfo = null;375 if (displayId == DEFAULT_DISPLAY) &#123;376 homeIntent = mService.getHomeIntent();377 aInfo = resolveHomeActivity(userId, homeIntent);378 &#125; else if (shouldPlaceSecondaryHomeOnDisplay(displayId)) &#123;379 Pair&lt;ActivityInfo, Intent&gt; info = resolveSecondaryHomeActivity(userId, displayId);380 aInfo = info.first;381 homeIntent = info.second;382 &#125;383 if (aInfo == null || homeIntent == null) &#123;384 return false;385 &#125;386387 if (!canStartHomeOnDisplay(aInfo, displayId, allowInstrumenting)) &#123;388 return false;389 &#125;390391 // Updates the home component of the intent.392 homeIntent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));393 homeIntent.setFlags(homeIntent.getFlags() | FLAG_ACTIVITY_NEW_TASK);394 // Updates the extra information of the intent.395 if (fromHomeKey) &#123;396 homeIntent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, true);397 &#125;398 // Update the reason for ANR debugging to verify if the user activity is the one that399 // actually launched.400 final String myReason = reason + \":\" + userId + \":\" + UserHandle.getUserId(401 aInfo.applicationInfo.uid) + \":\" + displayId;402 mService.getActivityStartController().startHomeActivity(homeIntent, aInfo, myReason,403 displayId);404 return true;405 &#125; ​ 当displayId等于DEFAULT_DISPLAY，即主显的时候，必然会给其找一个Launcher进行启动。当displayId不是DEFAULT_DISPLAY，即非主显时，就要过三关了： ​ 第一关，系统是否支持SecondaryHomeOnDisplay–shouldPlaceSecondaryHomeOnDisplay，如果系统没有配置打开，那么AMS就不会启动双Home了。 ​ 第二关，系统中有定义SecondaryHomeActivity–resolveSecondaryHomeActivity，如果没有第二个Launcher，那么也就没有可以使用的Activity，AMS根本就没法启动。 ​ 第三关，检查是否允许在对应的display中启动Home–canStartHomeOnDisplay，如果是AMS在启动的时候，是不会有问题的。 shouldPlaceSecondaryHomeOnDisplay​ 先看第一关考验的内容： 12345678910111213141516171819202122232425262728293031323334540 boolean shouldPlaceSecondaryHomeOnDisplay(int displayId) &#123;541 if (displayId == DEFAULT_DISPLAY) &#123;542 throw new IllegalArgumentException(543 \"shouldPlaceSecondaryHomeOnDisplay: Should not be DEFAULT_DISPLAY\");544 &#125; else if (displayId == INVALID_DISPLAY) &#123;545 return false;546 &#125;547548 if (!mService.mSupportsMultiDisplay) &#123;549 // Can't launch home on secondary display if device does not support multi-display.550 return false;551 &#125;552553 final boolean deviceProvisioned = Settings.Global.getInt(554 mService.mContext.getContentResolver(),555 Settings.Global.DEVICE_PROVISIONED, 0) != 0;556 if (!deviceProvisioned) &#123;557 // Can't launch home on secondary display before device is provisioned.558 return false;559 &#125;560561 if (!StorageManager.isUserKeyUnlocked(mCurrentUser)) &#123;562 // Can't launch home on secondary displays if device is still locked.563 return false;564 &#125;565566 final ActivityDisplay display = getActivityDisplay(displayId);567 if (display == null || display.isRemoved() || !display.supportsSystemDecorations()) &#123;568 // Can't launch home on display that doesn't support system decorations.569 return false;570 &#125;571572 return true;573 &#125; ​ mService.mSupportsMultiDisplay是指系统是否支持多屏幕，其决定因素有： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748721 public void retrieveSettings(ContentResolver resolver) &#123;722 final boolean freeformWindowManagement =723 mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)724 || Settings.Global.getInt(725 resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, 0) != 0;726727 final boolean supportsMultiWindow = ActivityTaskManager.supportsMultiWindow(mContext);728 final boolean supportsPictureInPicture = supportsMultiWindow &amp;&amp;729 mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE);730 final boolean supportsSplitScreenMultiWindow =731 ActivityTaskManager.supportsSplitScreenMultiWindow(mContext);732 final boolean supportsMultiDisplay = mContext.getPackageManager()733 .hasSystemFeature(FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);734 final boolean forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, 0) != 0;735 final boolean forceResizable = Settings.Global.getInt(736 resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0;737 final boolean isPc = mContext.getPackageManager().hasSystemFeature(FEATURE_PC);738739 // Transfer any global setting for forcing RTL layout, into a System Property740 DisplayProperties.debug_force_rtl(forceRtl);741742 final Configuration configuration = new Configuration();743 Settings.System.getConfiguration(resolver, configuration);744 if (forceRtl) &#123;745 // This will take care of setting the correct layout direction flags746 configuration.setLayoutDirection(configuration.locale);747 &#125;748749 synchronized (mGlobalLock) &#123;750 mForceResizableActivities = forceResizable;751 final boolean multiWindowFormEnabled = freeformWindowManagement752 || supportsSplitScreenMultiWindow753 || supportsPictureInPicture754 || supportsMultiDisplay;755 if ((supportsMultiWindow || forceResizable) &amp;&amp; multiWindowFormEnabled) &#123;756 mSupportsMultiWindow = true;757 mSupportsFreeformWindowManagement = freeformWindowManagement;758 mSupportsSplitScreenMultiWindow = supportsSplitScreenMultiWindow;759 mSupportsPictureInPicture = supportsPictureInPicture;760 mSupportsMultiDisplay = supportsMultiDisplay;761 &#125; else &#123;762 mSupportsMultiWindow = false;763 mSupportsFreeformWindowManagement = false;764 mSupportsSplitScreenMultiWindow = false;765 mSupportsPictureInPicture = false;766 mSupportsMultiDisplay = false;767 &#125; ……… ​ 从代码中可以看到，supportsMultiDisplay要为true，那么就需要满足以下的条件：①.系统有配置android.software.activities_on_secondary_displays这个feature，如果是LowRam设备，那么在配置中必须要加上notLowRam=false这个属性。②.支持多窗口模式–supportsMultiWindow(此次成立的条件是非LowRam设备或者是watch设备，且配置了config_supportsSplitScreenMultiWindow)或者系统支持窗口大小调整–forceResizable(settings global中设置force_resizable_activities为1).③.使能多窗口模式 – multiWindowFormEnabled，其实这条件在前面的条件成立后，自然也就成立。 ​ 在supportsMultiDisplay为true，后第二步就是要deviceProvisioned为true，这个值是从settings global中获取，而这个值是在开机向导(Provisions)结束后就会设置为true，这条件一般也会成立，我们无需在意。 ​ 第三步就是系统处于非锁屏状态，这也很好理解，当处于锁屏状态，Home是还没起来的。 ​ 第四步就是所传进来的Display是有效的且没有被移除，然后满足isplay.supportsSystemDecorations()返回true： 123456789101209 boolean supportsSystemDecorations() &#123;1210 return mDisplayContent.supportsSystemDecorations();1211 &#125;5023 boolean supportsSystemDecorations() &#123;5024 return (mWmService.mDisplayWindowSettings.shouldShowSystemDecorsLocked(this)5025 || (mDisplay.getFlags() &amp; FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS) != 05026 || (mWmService.mForceDesktopModeOnExternalDisplays &amp;&amp; !isUntrustedVirtualDisplay()))5027 // VR virtual display will be used to run and render 2D app within a VR experience.5028 &amp;&amp; mDisplayId != mWmService.mVr2dDisplayId;5029 &#125; ​ supportsSystemDecorations()返回true满足的条件：①.该Display不是2D的VR屏。②.满足以下条件之一： ​ 一.mWmService.mDisplayWindowSettings.shouldShowSystemDecorsLocked()返回true： 12345678910111213343 boolean shouldShowSystemDecorsLocked(DisplayContent dc) &#123;344 if (dc.getDisplayId() == Display.DEFAULT_DISPLAY) &#123;345 // For default display should show system decors.346 return true;347 &#125;348349 final DisplayInfo displayInfo = dc.getDisplayInfo();350 final Entry entry = getEntry(displayInfo);351 if (entry == null) &#123;352 return false;353 &#125;354 return entry.mShouldShowSystemDecors;355 &#125; ​ 目前从Android的源码中没有看过设置这个值的地方，我们先跳过。 ​ 二.Display具备FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS这个flags，也没有从代码中看到相关的设置，也跳过。 ​ 三.mWmService.mForceDesktopModeOnExternalDisplays为true，且非不可信的虚拟屏，后者一般为true，前者就是我们最开始说的settings put global force_desktop_mode_on_external_displays 1： 1234567 999 private WindowManagerService(Context context, InputManagerService inputManager,1000 boolean showBootMsgs, boolean onlyCore, WindowManagerPolicy policy,1001 ActivityTaskManagerService atm, TransactionFactory transactionFactory) &#123; ……1119 mForceDesktopModeOnExternalDisplays = Settings.Global.getInt(resolver,1120 DEVELOPMENT_FORCE_DESKTOP_MODE_ON_EXTERNAL_DISPLAYS, 0) != 0; …… ​ 至此第一关就闯关成功。 resolveSecondaryHomeActivity​ 第二关就准备开始了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950443 @VisibleForTesting444 Pair&lt;ActivityInfo, Intent&gt; resolveSecondaryHomeActivity(int userId, int displayId) &#123;445 if (displayId &#x3D;&#x3D; DEFAULT_DISPLAY) &#123;446 throw new IllegalArgumentException(447 &quot;resolveSecondaryHomeActivity: Should not be DEFAULT_DISPLAY&quot;);448 &#125;449 &#x2F;&#x2F; Resolve activities in the same package as currently selected primary home activity.450 Intent homeIntent &#x3D; mService.getHomeIntent();451 ActivityInfo aInfo &#x3D; resolveHomeActivity(userId, homeIntent);452 if (aInfo !&#x3D; null) &#123;453 if (ResolverActivity.class.getName().equals(aInfo.name)) &#123;454 &#x2F;&#x2F; Always fallback to secondary home component if default home is not set.455 aInfo &#x3D; null;456 &#125; else &#123;457 &#x2F;&#x2F; Look for secondary home activities in the currently selected default home458 &#x2F;&#x2F; package.459 homeIntent &#x3D; mService.getSecondaryHomeIntent(aInfo.applicationInfo.packageName);460 final List&lt;ResolveInfo&gt; resolutions &#x3D; resolveActivities(userId, homeIntent);461 final int size &#x3D; resolutions.size();462 final String targetName &#x3D; aInfo.name;463 aInfo &#x3D; null;464 for (int i &#x3D; 0; i &lt; size; i++) &#123;465 ResolveInfo resolveInfo &#x3D; resolutions.get(i);466 &#x2F;&#x2F; We need to traverse all resolutions to check if the currently selected467 &#x2F;&#x2F; default home activity is present.468 if (resolveInfo.activityInfo.name.equals(targetName)) &#123;469 aInfo &#x3D; resolveInfo.activityInfo;470 break;471 &#125;472 &#125;473 if (aInfo &#x3D;&#x3D; null &amp;&amp; size &gt; 0) &#123;474 &#x2F;&#x2F; First one is the best.475 aInfo &#x3D; resolutions.get(0).activityInfo;476 &#125;477 &#125;478 &#125;479480 if (aInfo !&#x3D; null) &#123;481 if (!canStartHomeOnDisplay(aInfo, displayId, false &#x2F;* allowInstrumenting *&#x2F;)) &#123;482 aInfo &#x3D; null;483 &#125;484 &#125;485486 &#x2F;&#x2F; Fallback to secondary home component.487 if (aInfo &#x3D;&#x3D; null) &#123;488 homeIntent &#x3D; mService.getSecondaryHomeIntent(null);489 aInfo &#x3D; resolveHomeActivity(userId, homeIntent);490 &#125;491 return Pair.create(aInfo, homeIntent);492 &#125; ​ 第二关的核心方法就是mService.getSecondaryHomeIntent，其中从上面的代码中看到，有两种情况，传入了两个不同的参数，第一个是已经启动的Home所在的包名，第二个是null. 1234567891011121314151617185869 Intent getSecondaryHomeIntent(String preferredPackage) &#123;5870 final Intent intent &#x3D; new Intent(mTopAction, mTopData !&#x3D; null ? Uri.parse(mTopData) : null);5871 final boolean useSystemProvidedLauncher &#x3D; mContext.getResources().getBoolean(5872 com.android.internal.R.bool.config_useSystemProvidedLauncherForSecondary);5873 if (preferredPackage &#x3D;&#x3D; null || useSystemProvidedLauncher) &#123;5874 &#x2F;&#x2F; Using the component stored in config if no package name or forced.5875 final String secondaryHomeComponent &#x3D; mContext.getResources().getString(5876 com.android.internal.R.string.config_secondaryHomeComponent);5877 intent.setComponent(ComponentName.unflattenFromString(secondaryHomeComponent));5878 &#125; else &#123;5879 intent.setPackage(preferredPackage);5880 &#125;5881 intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);5882 if (mFactoryTest !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;5883 intent.addCategory(Intent.CATEGORY_SECONDARY_HOME);5884 &#125;5885 return intent;5886 &#125; ​ 如果将config_useSystemProvidedLauncherForSecondary配置为true，那么就会使用config_secondaryHomeComponent所配置的Home，这种做法可用于指定特定的SecondaryHome。但config_useSystemProvidedLauncherForSecondary默认是false，也就是会根据已启动的Home所在的包中的CATEGORY_SECONDARY_HOME定义的Home，因为一些Launcher会有支持上SecondaryHome，当launcher中找不到SecondaryHome，才会去使用默认的SecondaryHome。第二种情况是主显的launcher没有启动时走的流程，也就是使用默认的SecondaryHome。 ​ 至此就完成了查找SecondaryHome的任务。 canStartHomeOnDisplay1234567891011121314151617181920212223242526272829303132333435582 boolean canStartHomeOnDisplay(ActivityInfo homeInfo, int displayId,583 boolean allowInstrumenting) &#123;584 if (mService.mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL585 &amp;&amp; mService.mTopAction == null) &#123;586 // We are running in factory test mode, but unable to find the factory test app, so587 // just sit around displaying the error message and don't try to start anything.588 return false;589 &#125;590591 final WindowProcessController app =592 mService.getProcessController(homeInfo.processName, homeInfo.applicationInfo.uid);593 if (!allowInstrumenting &amp;&amp; app != null &amp;&amp; app.isInstrumenting()) &#123;594 // Don't do this if the home app is currently being instrumented.595 return false;596 &#125;597598 if (displayId == DEFAULT_DISPLAY || (displayId != INVALID_DISPLAY599 &amp;&amp; displayId == mService.mVr2dDisplayId)) &#123;600 // No restrictions to default display or vr 2d display.601 return true;602 &#125;603604 if (!shouldPlaceSecondaryHomeOnDisplay(displayId)) &#123;605 return false;606 &#125;607608 final boolean supportMultipleInstance = homeInfo.launchMode != LAUNCH_SINGLE_TASK609 &amp;&amp; homeInfo.launchMode != LAUNCH_SINGLE_INSTANCE;610 if (!supportMultipleInstance) &#123;611 // Can't launch home on secondary displays if it requested to be single instance.612 return false;613 &#125;614615 return true;616 &#125; ​ canStartHomeOnDisplay的核心是shouldPlaceSecondaryHomeOnDisplay，而这个就是我们第一关的内容，因此毫无疑问，这关轻松闯过。 startHomeActivity​ 闯完三关后，就到了真正的启动，从前面的参数可以知道，HomeActivity的启动必定加上FLAG_ACTIVITY_NEW_TASK这个flag参数，表示HomeActivity是要在新的Task中启动的，这很容易理解。 ​ 我们继续看startHomeActivity是如何将Home启动到副屏上的： 123456789101112131415161718192021222324252627171 void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason, int displayId) &#123;172 final ActivityOptions options = ActivityOptions.makeBasic();173 options.setLaunchWindowingMode(WINDOWING_MODE_FULLSCREEN);174 if (!ActivityRecord.isResolverActivity(aInfo.name)) &#123;175 // The resolver activity shouldn't be put in home stack because when the foreground is176 // standard type activity, the resolver activity should be put on the top of current177 // foreground instead of bring home stack to front.178 options.setLaunchActivityType(ACTIVITY_TYPE_HOME);179 &#125;180 options.setLaunchDisplayId(displayId);181 mLastHomeActivityStartResult = obtainStarter(intent, \"startHomeActivity: \" + reason)182 .setOutActivity(tmpOutRecord)183 .setCallingUid(0)184 .setActivityInfo(aInfo)185 .setActivityOptions(options.toBundle())186 .execute();187 mLastHomeActivityStartRecord = tmpOutRecord[0];188 final ActivityDisplay display =189 mService.mRootActivityContainer.getActivityDisplay(displayId);190 final ActivityStack homeStack = display != null ? display.getHomeStack() : null;191 if (homeStack != null &amp;&amp; homeStack.mInResumeTopActivity) &#123;192 // If we are in resume section already, home activity will be initialized, but not193 // resumed (to avoid recursive resume) and will stay that way until something pokes it194 // again. We need to schedule another resume.195 mSupervisor.scheduleResumeTopActivities();196 &#125;197 &#125; ​ 显示到副屏的关键是–options.setLaunchDisplayId(displayId)，ActivityOptions是Activity的启动参数，setLaunchDisplayId就是设置了Activity在哪个display上进行启动。而这个详细的过程可以看am命令在副屏上启动Activity的详细分析。 总结​ 总的来说，AndroidQ已经支持得十分好，如果需要打开双Home启动，那么可以通过以下步骤去进行。 ​ 1.最好将设备设置为非LowRam设备。 ​ 2.打开多窗口模式，如果是非LowRam设备，默认也是打开的。 ​ 3.准备一个SecondaryHome应用，Android提供的Launcher3其实已经支持，但也可以自行配置。 ​ 4.通过settings put global force_desktop_mode_on_external_displays 1去打开双Home。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"AMS","slug":"AMS","permalink":"https://chongyuzhao.github.io/tags/AMS/"}]},{"title":"Android多屏幕专题--开篇","date":"2020-03-21T13:58:57.000Z","path":"2020/03/21/Android多屏幕专题-开篇/","text":"Android多屏幕​ Android从4.4开始其实就已经有了(不确定最初是哪个版本)，在Android6.0的时候就有Presentation作为异显开发，而到AndroidQ，就已经发现有双Home(两个launcher，可以在两个显示屏上打开应用)。而我对这一块一直都比较感兴趣，而且涉及了Android frameworks很多的内容，诸如AMS、WMS、DisplayManagerService、SurfaceFlinger和Input等等。随着嵌入式芯片的性能越来越强，多屏操作也就不再吃力，Android也越来越接近像windows那样强大的界面操作能力。 分析步骤​ 由于多屏幕异显部分设计的子系统繁多，我们将逐一分块进行分析，大概步骤如下: ​ 1.从双home场景进行分析，了解两个Home是如何启动与显示。 ​ 2.了解Presentation的原理，分析其是如何显示到其他的屏幕上。 ​ 3.了解AMS是如何管理多个屏幕的，如何组织或者启动一个Activity到另一个屏幕上。 ​ 4.了解WMS是如何管理多个屏幕的windows。 ​ 5.了解SurfaceFlinger是如何合成和显示不同屏幕的视图。 ​ 6.了解InputFlinger的不同屏幕的Viewport更新机制。 ​ ……","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"AMS","slug":"AMS","permalink":"https://chongyuzhao.github.io/tags/AMS/"},{"name":"WMS","slug":"WMS","permalink":"https://chongyuzhao.github.io/tags/WMS/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android Input子系统专题-输入路由","date":"2020-03-20T13:19:34.000Z","path":"2020/03/20/input/Android-Input子系统专题-输入路由/","text":"Android Input输入路由​ 路由在我们生活中基本都有接触，而我们这里说的输入路由主要是用在多屏幕多触摸输入设备中，设计者可以为对应的屏幕指定对应的输入设备，而这功能就是所谓的输入路由。 ​ 从InputFlinger的学习中我们知道，在InputFlinger中没有屏幕(Screen)的概念，而我们的输入事件是通过查找对应的Viewport(视口)来发送到对应的窗口，而窗口在指定的屏幕上，也即是对应的输入事件发送到指定的屏幕中。在底层我们是不知道哪个触摸设备对应哪个屏幕的，例如当有两个HDMI设备时，那么我们哪个触摸设备对应哪个显示器呢，这是很不好去判断的，一般查找Viewport有以下4种情况： ​ 1.如果有在设备路由表中定义，则根据路由表的display id进行查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 2.如果idc配置文件中有定义touch.displayId字段，则根据该字段进行匹配查找，且不论是否找到，都会直接返回(找不到对应的Viewport则返回NULL)。 ​ 3.根据设备类型进行查找，如果设备属于内置类型输入设备，则会匹配到内置的display，而如果属于外置输入设备，如usb触摸屏等，则会去匹配外置的display。 ​ 4.在第3点的以外情况，即如果是外置输入设备，但没有匹配到外置的display，则会匹配默认的内置display。 ​ 以上4种情况可直接参考TouchInputMapper::findViewport的具体实现。 ​ 输入路由就是针对第一种情况。具体的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940413458 std::optional&lt;DisplayViewport&gt; TouchInputMapper::findViewport() &#123;3459 if (mParameters.hasAssociatedDisplay) &#123;3460 const std::optional&lt;uint8_t&gt; displayPort = mDevice-&gt;getAssociatedDisplayPort();3461 if (displayPort) &#123;3462 // Find the viewport that contains the same port3463 std::optional&lt;DisplayViewport&gt; v = mConfig.getDisplayViewportByPort(*displayPort);3464 if (!v) &#123;3465 ALOGW(\"Input device %s should be associated with display on port %\" PRIu8 \", \"3466 \"but the corresponding viewport is not found.\",3467 getDeviceName().c_str(), *displayPort);3468 &#125;3469 return v;3470 &#125; ……3501 &#125; 262 inline std::optional&lt;uint8_t&gt; getAssociatedDisplayPort() const &#123; 263 return mAssociatedDisplayPort; 264 &#125; 1067 void InputDevice::configure(nsecs_t when, const InputReaderConfiguration* config, uint32_t changes) &#123;1068 mSources = 0;1069 ……11001101 if (!changes || (changes &amp; InputReaderConfiguration::CHANGE_DISPLAY_INFO)) &#123;1102 // In most situations, no port will be specified.1103 mAssociatedDisplayPort = std::nullopt;1104 // Find the display port that corresponds to the current input port.1105 const std::string&amp; inputPort = mIdentifier.location;1106 if (!inputPort.empty()) &#123;1107 const std::unordered_map&lt;std::string, uint8_t&gt;&amp; ports = config-&gt;portAssociations;1108 const auto&amp; displayPort = ports.find(inputPort);1109 if (displayPort != ports.end()) &#123;1110 mAssociatedDisplayPort = std::make_optional(displayPort-&gt;second);1111 &#125;1112 &#125;1113 &#125;1114 ……1120 &#125; ​ 从上述的代码可以看到，输入路由就是通过InputDevice的location来从portAssociations表中去查找display。portAssociations的值我们可以逆推找到，也可以从官网的介绍文档中得知 – /vendor/etc/input-port-associations.xml，值的获取如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501905 private static String[] getInputPortAssociations() &#123;1906 File baseDir = Environment.getVendorDirectory();1907 File confFile = new File(baseDir, PORT_ASSOCIATIONS_PATH);19081909 try &#123;1910 InputStream stream = new FileInputStream(confFile);1911 List&lt;Pair&lt;String, String&gt;&gt; associations =1912 ConfigurationProcessor.processInputPortAssociations(stream);1913 List&lt;String&gt; associationList = flatten(associations);1914 return associationList.toArray(new String[0]);1915 &#125; catch (FileNotFoundException e) &#123;1916 // Most of the time, file will not exist, which is expected.1917 &#125; catch (Exception e) &#123;1918 Slog.e(TAG, \"Could not parse '\" + confFile.getAbsolutePath() + \"'\", e);1919 &#125;1920 return new String[0];1921 &#125; 88 @VisibleForTesting 89 static List&lt;Pair&lt;String, String&gt;&gt; processInputPortAssociations(InputStream xml) 90 throws Exception &#123; 91 List&lt;Pair&lt;String, String&gt;&gt; associations = new ArrayList&lt;&gt;(); 92 try (InputStreamReader confReader = new InputStreamReader(xml)) &#123; 93 XmlPullParser parser = Xml.newPullParser(); 94 parser.setInput(confReader); 95 XmlUtils.beginDocument(parser, \"ports\"); 96 97 while (true) &#123; 98 XmlUtils.nextElement(parser); 99 String entryName = parser.getName();100 if (!\"port\".equals(entryName)) &#123;101 break;102 &#125;103 String inputPort = parser.getAttributeValue(null, \"input\");104 String displayPort = parser.getAttributeValue(null, \"display\");105 if (TextUtils.isEmpty(inputPort) || TextUtils.isEmpty(displayPort)) &#123;106 // This is likely an error by an OEM during device configuration107 Slog.wtf(TAG, \"Ignoring incomplete entry\");108 continue;109 &#125;110 try &#123;111 Integer.parseUnsignedInt(displayPort);112 &#125; catch (NumberFormatException e) &#123;113 Slog.wtf(TAG, \"Display port should be an integer\");114 continue;115 &#125;116 associations.add(new Pair&lt;&gt;(inputPort, displayPort));117 &#125;118 &#125;119 return associations;120 &#125; ​ 从代码上看，输入路由的配置文件input-port-associations.xml的格式如下： 1234&lt;ports&gt; &lt;port display=\"0\" input=\"usb-xhci-hcd.0.auto-1.1/input0\" /&gt; &lt;port display=\"1\" input=\"usb-xhci-hcd.0.auto-1.2/input0\" /&gt;&lt;/ports&gt; ​ 顶层以为tag，子节点为一组display-input配置。display属性是一个整形值，对应了displayId，input属性是输入设备的描述。回顾InputDevice::configure方法的内容，input的字段对应了InputDevice的location字段。displayId我们很好理解，就是显示设备在Display系统中的idz中，我们可以通过dumpsys display来获取，而这个location值也可以通过dumpsys input来获取设备对应的值。display的值是一个整数，范围是[0,255]。 ​ 我们再看以下location这个值是从哪里来的： 12345678910111189 status_t EventHub::openDeviceLocked(const char* devicePath) &#123; ……1240 // Get device physical location.1241 if(ioctl(fd, EVIOCGPHYS(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;1242 //fprintf(stderr, \"could not get location for %s, %s\\n\", devicePath, strerror(errno));1243 &#125; else &#123;1244 buffer[sizeof(buffer) - 1] = '\\0';1245 identifier.location = buffer;1246 &#125; ……1477 &#125; ​ location就是input设备驱动中的phys。 总结​ 输入路由其实就是简单的由一个xml文件对输入设备(触摸设备)和显示设备之间进行绑定。我觉得可以由以下的用途： ​ 1.多个外置的输入设备和显示设备，需要指定对应的输入和显示设备关系，可以使用输入路由控制。 ​ 2.一个内置一个外置的输入设备和显示设备。当两个显示器进行同显时(此时只有一个viewport)，那么两个输入设备都可以控制主显，而我们又不希望如此时，可以通过输入路由指定外置输入设备控制外置显示设备(即当只有异显时才生效)。 ​ 3.将某个输入设备的display设成一个不存在的displayId，那么就可以禁止掉输入设备的事件(有点多此一举，因为可通过excluded-input-devices.xml让对应的设备不进行注册，但这种做法可以禁止掉一类型的输入设备事件上报，也不失为一种方式)。 ​ 如果大家还有其他想到的用途，欢迎交流~ ，","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"}]},{"title":"Android Input子系统专题-InputFlinger(一)","date":"2020-03-15T13:39:40.000Z","path":"2020/03/15/input/Android-Input子系统专题-InputFlinger(一)/","text":"InputFlinger的启动​ InputFlinger的源码在frameworks/native/services/inputflinger目录下，其是作为一个lib而存在，因此启动的代码也并不在这里。InputFlinger实际上是通过IMS的JNI启动起来的，在InputFlinger的源码目录下，是没有InputFlinger这么一个东西，host目录下的内容实际上并没有使用到。虽然没有InputFlinger这个类，但既然叫InputFlinger，那当然与这个名字有关系，我们可以看到，有一个BnInputFlinger的接口，而InputManager继承了这个接口，说明InputManager就是InputFlinger的service端： 181 class InputManager : public InputManagerInterface, public BnInputFlinger &#123; ​ 那么这个InputManager是被谁创建启动的呢？一般这种情况不是通过rc文件启动的，就很高概率是android的Java服务通过JNI去创建和启动服务了： 123456789101112131415161718192021222324252627282930313233343536// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp 333 NativeInputManager::NativeInputManager(jobject contextObj, 334 jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) : 335 mLooper(looper), mInteractive(true) &#123; 336 JNIEnv* env = jniEnv(); 337 338 mServiceObj = env-&gt;NewGlobalRef(serviceObj); 339 340 &#123; 341 AutoMutex _l(mLock); 342 mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE; 343 mLocked.pointerSpeed = 0; 344 mLocked.pointerGesturesEnabled = true; 345 mLocked.showTouches = false; 346 mLocked.pointerCapture = false; 347 mLocked.pointerDisplayId = ADISPLAY_ID_DEFAULT; 348 &#125; 349 mInteractive = true; 350 351 mInputManager = new InputManager(this, this); 352 defaultServiceManager()-&gt;addService(String16(\"inputflinger\"), 353 mInputManager, false); 354 &#125;1317 static jlong nativeInit(JNIEnv* env, jclass /* clazz */,1318 jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;1319 sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);1320 if (messageQueue == nullptr) &#123;1321 jniThrowRuntimeException(env, \"MessageQueue is not initialized.\");1322 return 0;1323 &#125;13241325 NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,1326 messageQueue-&gt;getLooper());1327 im-&gt;incStrong(0);1328 return reinterpret_cast&lt;jlong&gt;(im);1329 &#125; ​ NativeInputManager在创建了InputManager后就将其注册到servicemanager中，并将其命名为Inputflinger。 ​ 从文件名我们就可以得知这部分属于InputManagerService的JNI部分，也就是说InputManagerService在启动的过程中，就会启动InputFlinger. InputFlinger的核心​ 看完InputFlinger是由谁启动的之后，我们再会过头来看看InputFlinger在启动的过程中干了哪些事，看看哪些是我们后续学习的重点。 1234567833 InputManager::InputManager(34 const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,35 const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;36 mDispatcher = new InputDispatcher(dispatcherPolicy);37 mClassifier = new InputClassifier(mDispatcher);38 mReader = createInputReader(readerPolicy, mClassifier);39 initialize();40 &#125; ​ InputManager在构造的过程中，创建了三个重要的对象，分别是mDispatcher(InputDispatcher)、mClassifier(InputClassifier)和mReader(InputReader)。这三个东西中InputDispatcher和InputReader在之前的工作中接触得最多，而InputClassifer倒是很少接触，后续会研究以下这东西是干嘛的。 123446 void InputManager::initialize() &#123;47 mReaderThread = new InputReaderThread(mReader);48 mDispatcherThread = new InputDispatcherThread(mDispatcher);49 &#125; ​ 之后就为mReader和mDispatcher分别创建一个线程去分工合作，由此可以看到，InputFlinger至少是有两个子线程在跑的。创建子线程之后当然就是去执行它们，这我们就不在这里展开了。 小结​ InputFlinger的核心实际上就只有两个半：InputDispatcher和InputReader，还有一个未知的InputClassifier，我们后续的工作主要就是去分析这两个核心干了哪些大事。 ​ 下图是InputFlinger的类图：","tags":[{"name":"Input","slug":"Input","permalink":"https://chongyuzhao.github.io/tags/Input/"},{"name":"AndroidQ","slug":"AndroidQ","permalink":"https://chongyuzhao.github.io/tags/AndroidQ/"}]},{"title":"Android input子系统专题--开篇","date":"2020-03-15T05:16:00.000Z","path":"2020/03/15/input/Android-input子系统专题-开篇/","text":"Android Input的分层​ Android的input子系统大概是在2019年的3、4月份开始接触的，主要是因为负责Input部分的同事离职了，我就当仁不让地接上了这个话。Android是一个交互式的操作系统，显示与输入都是一个重要的组成部分。Android支持多种多样的输入设备，如触摸、游戏手柄、按键、鼠标、键盘等等。 ​ 基于Android与Linux的关系，Android的input子系统也是可分成三层：设备驱动层 - inputflinger层 - 应用处理层。设备驱动层与inputflinger层之间是通过Linux的设备驱动节点进行连接，inputflinger与应用层之前是通过InputChannel来进行连接。 123graph BTDriver[设备驱动] &#x3D;&#x3D; VFS &#x3D;&#x3D;&gt; InputFlinger[InputFlinger]InputFlinger[InputFlinger] &#x3D;&#x3D; InputChannel &#x3D;&#x3D;&gt; APP[应用] ​ 设备驱动层决定了系统支持什么类型的设备，没有对应的驱动配置就成了巧妇难为无米之炊，如果没有触摸驱动，那么如何来触摸，USB没有配置好，那么USB鼠标键盘如何使用。设备驱动层是基础，后面在对这部分分析的时候，我们不针对具体的设备驱动，而是对input事件的从驱动层到用户节点的过程。 ​ inputflinger是Android的快递员，接收底层驱动投递的输入事件，然后经过封装分发给对应的客户。这一块也是目前接触最多的部分，后面将重点分析这一块。 ​ 应用层则是Android真正处理事件的地方，输入事件的存在感就是由处理它的人体验的，这一部分很多时候已经被各种view给处理，剩余的则由应用去处理，平时我们所override的onKeyDown/onTouchEvent等等回调，就是我们研究的对象。 分析步骤1. InputFlinger的工作原理 1. 设备的配置文件 2. KeyEvent的处理过程 3. TouchEvent的处理过程 2. InputChannel的创建 3. InputFlinger分发事件到应用的过程 4. Driver的事件上报过程。总结​ 学无止境，每次重新看代码都会有不同的感悟，特别是Android版本的更新频繁，虽大体的框架不会变动太大，但也是有无穷的东西需要学习和总结。","tags":[{"name":"Android","slug":"Android","permalink":"https://chongyuzhao.github.io/tags/Android/"},{"name":"input","slug":"input","permalink":"https://chongyuzhao.github.io/tags/input/"}]}]